const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/multi-connect-provider-YOTZYVBH-B7vBlZts.js","assets/index-B_Ed81Ho.js","assets/index.esm-DhwY4kHm.js","assets/import-wrapper-prod-BvIURD_x.js","assets/index.esm-COc-PyqV.js","assets/index.esm-5Aerb1sL.js","assets/index.esm-mHhT2Jqf.js","assets/tap-DGvjHJum.js"])))=>i.map(i=>d[i]);
import{_ as P}from"./index-B_Ed81Ho.js";import{E as Tt,B as N,C as St,t as bt,u as _t,v as xt,T as qt,x as ct,y,z as F,A as zt,D as ot,F as Mt,G as dt,H as Ot,I as ut,J as W,K as Rt,M as T,N as jt,O as kt,P as ht,Q as Lt,R as Nt,S as _,V as lt,W as Ft,X as Ut,Y as Bt,Z as Vt,_ as Ht,$ as Gt,a0 as Jt,a1 as Yt,a2 as Kt,a3 as Qt,a4 as Xt,a5 as Zt,a6 as te,a7 as ee,d as re,s as u,o as A,a8 as Z,a9 as D,b as ne,g as pt,m as ae}from"./index.esm-mHhT2Jqf.js";import{O as ft,d as se,o as wt,c as At,S as vt,C as ie,s as M,m as v,a as p,e as ce,f as oe,b as tt}from"./index.esm-DhwY4kHm.js";import{storage as l}from"./index.esm-COc-PyqV.js";import{B as O,c as E}from"./combineLatest-Bzt_9bb6.js";import{d as gt}from"./defer-BRewiDsk.js";import{f as mt,t as Ct}from"./takeUntil-B9okj2Im.js";import{t as I}from"./tap-DGvjHJum.js";import{a as de}from"./asap-D-qxMtYG.js";import{f as R}from"./firstValueFrom-RTAQ66ca.js";function et(t,e){var r=se(t)?t:function(){return t},n=function(a){return a.error(r())};return new ft(n)}function yt(t){return wt(function(e,r){var n=!1;e.subscribe(At(r,function(a){n=!0,r.next(a)},function(){n||r.next(t),r.complete()}))})}function ue(t){return t<=0?function(){return Tt}:wt(function(e,r){var n=0;e.subscribe(At(r,function(a){++n<=t&&(r.next(a),t<=n&&r.complete())}))})}class S extends N{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:e,docsSlug:"account",name:"AccountNotFoundError"})}}class x extends N{constructor({docsPath:e,metaMessages:r,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:e,metaMessages:r,name:"AccountTypeNotSupportedError"})}}function It({chain:t,currentChainId:e}){if(!t)throw new St;if(e!==t.id)throw new bt({chain:t,currentChainId:e})}function he(t,{docsPath:e,...r}){const n=(()=>{const a=_t(t,r);return a instanceof xt?t:a})();return new qt(n,{docsPath:e,...r})}async function U(t,e){var G,J,Y,K;const{account:r=t.account,chain:n=t.chain,accessList:a,authorizationList:s,blobs:i,data:c,gas:d,gasPrice:h,maxFeePerBlobGas:g,maxFeePerGas:m,maxPriorityFeePerGas:C,nonce:B,value:V,...H}=e;if(!r)throw new S({docsPath:"/docs/actions/wallet/sendTransaction"});const f=W(r);try{ct(e);let w;n!==null&&(w=await y(t,F,"getChainId")({}),It({currentChainId:w,chain:n}));const Q=await(async()=>{if(e.to)return e.to;if(s&&s.length>0)return await zt({authorization:s[0]}).catch(()=>{throw new N("`to` is required. Could not infer from `authorizationList`.")})})();if(f.type==="json-rpc"){const $=(Y=(J=(G=t.chain)==null?void 0:G.formatters)==null?void 0:J.transactionRequest)==null?void 0:Y.format,b=($||ot)({...Mt(H,{format:$}),accessList:a,authorizationList:s,blobs:i,chainId:w,data:c,from:f.address,gas:d,gasPrice:h,maxFeePerBlobGas:g,maxFeePerGas:m,maxPriorityFeePerGas:C,nonce:B,to:Q,value:V});return await t.request({method:"eth_sendTransaction",params:[b]},{retryCount:0})}if(f.type==="local"){const $=await y(t,dt,"prepareTransactionRequest")({account:f,accessList:a,authorizationList:s,blobs:i,chain:n,chainId:w,data:c,gas:d,gasPrice:h,maxFeePerBlobGas:g,maxFeePerGas:m,maxPriorityFeePerGas:C,nonce:B,parameters:[...Ot,"sidecars"],value:V,...H,to:Q}),X=(K=n==null?void 0:n.serializers)==null?void 0:K.transaction,b=await f.signTransaction($,{serializer:X});return await y(t,ut,"sendRawTransaction")({serializedTransaction:b})}throw f.type==="smart"?new x({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new x({docsPath:"/docs/actions/wallet/sendTransaction",type:f.type})}catch(w){throw w instanceof x?w:he(w,{...e,account:f,chain:e.chain||void 0})}}async function le(t,e){const{abi:r,address:n,args:a,dataSuffix:s,functionName:i,...c}=e,d=Rt({abi:r,args:a,functionName:i});return y(t,U,"sendTransaction")({data:`${d}${s?s.replace("0x",""):""}`,to:n,...c})}async function pe(t,{chain:e}){const{id:r,name:n,nativeCurrency:a,rpcUrls:s,blockExplorers:i}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:T(r),chainName:n,nativeCurrency:a,rpcUrls:s.default.http,blockExplorerUrls:i?Object.values(i).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function fe(t,e={}){const{key:r="custom",name:n="Custom Provider",retryDelay:a}=e;return({retryCount:s})=>jt({key:r,name:n,request:t.request.bind(t),retryCount:e.retryCount??s,retryDelay:a,type:"custom"})}function we(t,e){if(t.length!==e.length)throw new kt({expectedLength:t.length,givenLength:e.length});const r=[];for(let n=0;n<t.length;n++){const a=t[n],s=e[n];r.push(Pt(a,s))}return ht(r)}function Pt(t,e,r=!1){if(t==="address"){const i=e;if(!Lt(i))throw new Nt({address:i});return _(i.toLowerCase(),{size:r?32:null})}if(t==="string")return lt(e);if(t==="bytes")return e;if(t==="bool")return _(Ft(e),{size:r?32:1});const n=t.match(Ut);if(n){const[i,c,d="256"]=n,h=Number.parseInt(d)/8;return T(e,{size:r?32:h,signed:c==="int"})}const a=t.match(Bt);if(a){const[i,c]=a;if(Number.parseInt(c)!==(e.length-2)/2)throw new Vt({expectedSize:Number.parseInt(c),givenSize:(e.length-2)/2});return _(e,{dir:"right",size:r?32:null})}const s=t.match(Ht);if(s&&Array.isArray(e)){const[i,c]=s,d=[];for(let h=0;h<e.length;h++)d.push(Pt(c,e[h],!0));return d.length===0?"0x":ht(d)}throw new Gt(t)}function Ae(t,e){const{abi:r,args:n,bytecode:a,...s}=e,i=Jt({abi:r,args:n,bytecode:a});return U(t,{...s,data:i})}async function ve(t){var r;return((r=t.account)==null?void 0:r.type)==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(n=>Yt(n))}async function ge(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}async function me(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(r=>Kt(r))}async function Ce(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}async function ye(t,{account:e=t.account,message:r}){if(!e)throw new S({docsPath:"/docs/actions/wallet/signMessage"});const n=W(e);if(n.signMessage)return n.signMessage({message:r});const a=typeof r=="string"?lt(r):r.raw instanceof Uint8Array?Qt(r.raw):r.raw;return t.request({method:"personal_sign",params:[a,n.address]},{retryCount:0})}async function Ie(t,e){var h,g,m,C;const{account:r=t.account,chain:n=t.chain,...a}=e;if(!r)throw new S({docsPath:"/docs/actions/wallet/signTransaction"});const s=W(r);ct({account:s,...e});const i=await y(t,F,"getChainId")({});n!==null&&It({currentChainId:i,chain:n});const c=(n==null?void 0:n.formatters)||((h=t.chain)==null?void 0:h.formatters),d=((g=c==null?void 0:c.transactionRequest)==null?void 0:g.format)||ot;return s.signTransaction?s.signTransaction({...a,chainId:i},{serializer:(C=(m=t.chain)==null?void 0:m.serializers)==null?void 0:C.transaction}):await t.request({method:"eth_signTransaction",params:[{...d(a),chainId:T(i),from:s.address}]},{retryCount:0})}async function Pe(t,e){const{account:r=t.account,domain:n,message:a,primaryType:s}=e;if(!r)throw new S({docsPath:"/docs/actions/wallet/signTypedData"});const i=W(r),c={EIP712Domain:Xt({domain:n}),...e.types};if(Zt({domain:n,message:a,primaryType:s,types:c}),i.signTypedData)return i.signTypedData({domain:n,message:a,primaryType:s,types:c});const d=te({domain:n,message:a,primaryType:s,types:c});return t.request({method:"eth_signTypedData_v4",params:[i.address,d]},{retryCount:0})}async function $e(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:T(e)}]},{retryCount:0})}async function Ee(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}function De(t){return{addChain:e=>pe(t,e),deployContract:e=>Ae(t,e),getAddresses:()=>ve(t),getChainId:()=>F(t),getPermissions:()=>ge(t),prepareTransactionRequest:e=>dt(t,e),requestAddresses:()=>me(t),requestPermissions:e=>Ce(t,e),sendRawTransaction:e=>ut(t,e),sendTransaction:e=>U(t,e),signMessage:e=>ye(t,e),signTransaction:e=>Ie(t,e),signTypedData:e=>Pe(t,e),switchChain:e=>$e(t,e),watchAsset:e=>Ee(t,e),writeContract:e=>le(t,e)}}function We(t){const{key:e="wallet",name:r="Wallet Client",transport:n}=t;return ee({...t,key:e,name:r,transport:n,type:"walletClient"}).extend(De)}async function j(t,e,r){const n=$t(t,e,r);await n.requestAddresses().catch(s=>{var i,c;if(s.core===4001||(c=(i=s.message)==null?void 0:i.toLowerCase())!=null&&c.includes("user reject")||s.details==="Cancelled")throw s});const a=await n.getChainId();return t!==a&&await n.switchChain(pt(t)),n}function $t(t,e,r){return We({chain:pt(t),transport:fe(e),account:r})}function q(t,e){return new ft(r=>{const n=a=>{r.next(a)};return t.on(e,n),()=>{if("removeListener"in t)return t.removeListener(e,n);console.warn("unable to unsubscribe from provider",t,e)}})}var Et=class{constructor(t){this.info=t,this.provider$=new O(null),this.activeAddressInner$=new O(null),this.providerOrDisconnect$=ae(this.provider$,gt(()=>this.disconnect$).pipe(v(()=>null))),this.addresses$=this.providerOrDisconnect$.pipe(u(e=>e?tt(this.getAddresses()).pipe(u(r=>q(e,"accountsChanged").pipe(M(r)))):A([])),p({bufferSize:1,refCount:!0})),this.activeAddress$=E([this.addresses$,this.activeAddressInner$]).pipe(v(([e,r])=>r||e[0]),p({bufferSize:1,refCount:!0})),this.chainId$=this.providerOrDisconnect$.pipe(u(e=>e?tt(this.getChainId()).pipe(u(r=>q(e,"chainChanged").pipe(v(n=>rt(n)),M(r)))):A(null)),p({bufferSize:1,refCount:!0})),this.disconnect$=this.provider$.pipe(mt(Boolean),u(e=>q(e,"disconnect"))),this.isConnected$=this.activeAddress$.pipe(v(e=>!!e)),this.info$=A(t)}getInfo(){return this.info}setProvider(t){this.provider$.next(t)}async getAddresses(){const t=this.provider$.value;return t?await t.request({method:"eth_accounts"}):[]}async getActiveAddress(){const t=this.activeAddressInner$.value;return t||((await this.getAddresses())[0]??null)}async getChainId(){const t=this.provider$.value;if(!t)return null;const e=await t.request({method:"eth_chainId"}).catch(()=>null);return e?rt(e):null}async isConnected(){return!!await this.getActiveAddress()}setActiveAddress(t){this.activeAddressInner$.next(t)}};function rt(t){return typeof t=="number"?t:parseInt(t,16)}function Te(t){const{code:e,message:r}=t;return e===4001||(r==null?void 0:r.toLowerCase().includes("user rejected"))}var k=class{constructor(t){this.providerDetail=t,this.client=null,this.data=new Et(this.providerDetail.info)}async connect(t){return this.client=await j(t,this.providerDetail.provider),this.data.setProvider(this.providerDetail.provider),!0}async restoreConnect(t,e){this.data.setProvider(this.providerDetail.provider);const n=(await this.data.getAddresses()).length>0&&t!==null;return n?this.client=$t(t,this.providerDetail.provider):this.data.setProvider(null),!n&&e?this.connect(t):n}async disconnect(){return this.client=null,this.data.setProvider(null),!0}async changeChain(t){return this.client?(await this.client.switchChain({id:t}),!0):!1}async isConnected(){var e;return(await((e=this.client)==null?void 0:e.getAddresses())??[]).length>0}setActiveAddress(t){this.data.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await this.client.writeContract({...t,account:e})}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();try{return await this.client.signTypedData({...t,account:e})}catch(n){if(Te(n))throw n;console.log(n)}const r=JSON.stringify(t,Se);return await this.providerDetail.provider.request({method:"eth_signTypedData_v3",params:[e,r]})}};function Se(t,e){return typeof e=="bigint"?e.toString():e}function be(t){l.set("chainId",Number(t))}function Dt(){return l.get("chainId",Number)}function _e(t){l.set("activeAddress",t)}function xe(){return l.get("activeAddress",String)}function nt(t){l.set("activeWallet",t)}function at(){return l.get("activeWallet",String)}function qe(t){const e=l.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)||(r.add(t),l.set("connectedWallet",[...r.keys()]))}function ze(){return l.get("connectedWallet",JSON.parse)}function st(t){const e=l.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)&&(r.delete(t),l.set("connectedWallet",[...r.keys()]))}var z=new WeakMap;function o(t){if(z.has(t))return z.get(t);const e=we(["string","string","string"],[t.name,t.rdns??"",t.icon]).slice(0,10);return z.set(t,e),e}var Wt=class{constructor(t){this.dataProvider=t,this.chainIdInner$=new O(Dt()??ie.eth),this.currentActiveAdapter$=gt(()=>this.dataProvider.update$).pipe(M(null),v(()=>this.dataProvider.currentActiveAdapter),re(),p({bufferSize:1,refCount:!0})),this.currentActiveAdapterData$=this.currentActiveAdapter$.pipe(v(e=>(e==null?void 0:e.data)??null),p({bufferSize:1,refCount:!0})),this.info$=this.currentActiveAdapterData$.pipe(mt(Boolean),u(e=>e.info$)),this.addresses$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.addresses$)??A([])),I(e=>console.log(e)),p({bufferSize:1,refCount:!0})),this.activeAddress$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.activeAddress$)??A(null)),I(e=>e&&_e(e)),p({bufferSize:1,refCount:!0})),this.chainId$=E([this.currentActiveAdapterData$,this.chainIdInner$]).pipe(u(([e,r])=>(e==null?void 0:e.chainId$)??A(r)),I(e=>e&&be(e)),p({bufferSize:1,refCount:!0})),this.disconnect$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.disconnect$)??A()),p({bufferSize:1,refCount:!0})),this.isConnected$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.isConnected$)??A(!1)),p({bufferSize:1,refCount:!0})),E([this.activeAddress$,this.chainId$]).pipe(ce(de)).subscribe()}getInfo(){if(!this.dataProvider.currentActiveAdapter)throw new Error("");return this.dataProvider.currentActiveAdapter.data.getInfo()}async getAddresses(){const t=await this.getProviderDataAdapter();return t?await t.getAddresses():[]}async getActiveAddress(){if(!this.dataProvider.currentActiveAdapter)return null;const t=await this.getProviderDataAdapter();return t?await t.getActiveAddress():null}async getChainId(){if(!this.dataProvider.currentActiveAdapter)return this.chainIdInner$.value;const t=await this.getProviderDataAdapter();if(!t)return this.chainIdInner$.value;const e=await t.getChainId();return e||this.chainIdInner$.value}async isConnected(){if(!this.dataProvider.currentActiveAdapter)return!1;const t=await this.getProviderDataAdapter();return t?await t.isConnected():!1}async isActiveAddress(t,e){var i,c;const r=o(t),n=await((i=this.dataProvider.currentActiveAdapter)==null?void 0:i.data.getActiveAddress())??null,a=((c=this.dataProvider.currentActiveAdapter)==null?void 0:c.data.getInfo())??null,s=a?o(a):null;return!!n&&!!s&&r===s&&Z(n,e)}isActiveWallet(t){var a;const e=o(t),r=((a=this.dataProvider.currentActiveAdapter)==null?void 0:a.data.getInfo())??null,n=r?o(r):null;return!!n&&n===e}isActiveAddress$(t,e){const r=o(t);return E([this.currentActiveAdapter$,this.activeAddress$]).pipe(v(([n,a])=>{const s=n?o(n.data.getInfo()):null;return!!a&&!!s&&r===s&&Z(a,e)}))}isActiveWallet$(t){const e=o(t);return this.currentActiveAdapter$.pipe(v(r=>{const n=r?o(r.data.getInfo()):null;return!!n&&n===e}))}setChainId(t){this.chainIdInner$.next(t)}getProviderDataAdapter(){return R(this.currentActiveAdapterData$.pipe(Ct(D(0)),yt(null)))}};function Me(){return!!window.ethereum}async function L(t=window.ethereum){if(!t)throw new Error("injected provider not supported");return{provider:t,info:{walletId:"injectedWalletId",uuid:"injectedWallet",name:Re(),icon:await Oe()}}}var it={default:()=>P(()=>import("./default-icon-UF676TO4-57bNFlKZ.js"),[]).then(t=>t.icon),oneInchWallet:()=>P(()=>import("./one-inch-wallet-icon-5SPUNDFK-BHMg-Ox7.js"),[]).then(t=>t.icon)};function Oe(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?it.oneInchWallet():it.default()}function Re(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?"1inch wallet":"Browser wallet"}var je=class{constructor(t){this.providerDetail=t,this.provider=null,this.client=null,this.data=new Et(this.providerDetail.info)}async isConnected(){var t;return((t=this.provider)==null?void 0:t.isConnected())??!1}async connect(t){if(this.provider)await this.provider.connect();else{const e=await P(()=>import("./multi-connect-provider-YOTZYVBH-B7vBlZts.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(r=>r.MultiConnectProvider.connect());this.client=await j(t,e),this.data.setProvider(e),this.provider=e}return!0}async restoreConnect(){if(this.provider)await this.provider.restoreConnect();else{const t=await P(()=>import("./multi-connect-provider-YOTZYVBH-B7vBlZts.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(e=>e.MultiConnectProvider.restoreConnect());this.client=await j(t.chainId,t),this.data.setProvider(t),this.provider=t}return!0}async disconnect(){var t;return(t=this.provider)==null||t.disconnect(),!0}async changeChain(t){var e;return await((e=this.client)==null?void 0:e.switchChain({id:t})),!0}setActiveAddress(t){var e;(e=this.provider)==null||e.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.any([this.client.writeContract({...t,account:e}),R(D(60*1e3*3).pipe(u(()=>et(()=>new Error("wallet connect request timed out")))))])}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.race([this.client.signTypedData({...t,account:e}),R(D(60*1e3*3).pipe(u(()=>et(()=>new Error("wallet connect request timed out")))))])}};async function ke(){return{info:{walletId:"walletConnectId",uuid:"walletConnect",name:"Wallet Connect",icon:await Ne()}}}var Le={default:()=>P(()=>import("./wallet-connect-icon-NJ76IV67-lPk-W8Bs.js"),[]).then(t=>t.icon)};function Ne(){return Le.default()}var Fe=class{constructor(){this.data=new Wt(this),this.activeAdapters=new Map,this.update$=new vt,this.currentActiveAdapterId=null,this.adapters=new Map}get isConnected(){return this.currentActiveAdapter!==null}get currentActiveAdapter(){return this.currentActiveAdapterId?this.activeAdapters.get(this.currentActiveAdapterId)??null:null}async init(){await this.initWallets(),await this.restoreChainId(),await this.restoreWalletConnection(),this.update$.next()}async getSupportedWallets(){const t=[];return this.adapters.forEach(e=>t.push(e.data.getInfo())),t.sort((e,r)=>{const n=o(e),a=o(r);return n===this.currentActiveAdapterId&&a!==this.currentActiveAdapterId?-1:n!==this.currentActiveAdapterId&&a===this.currentActiveAdapterId?1:this.activeAdapters.has(n)&&this.activeAdapters.has(a)?0:this.activeAdapters.has(n)&&!this.activeAdapters.has(a)?-1:!this.activeAdapters.has(n)&&this.activeAdapters.has(a)?1:0})}async connect(t){const e=await this.data.getChainId(),r=o(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=await this.connectSafe(e,r);return this.afterConnectWallet(n,r),this.update$.next(),n}async addConnection(t){const e=await this.data.getChainId(),r=o(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=this.adapters.get(r);if(!n)throw new Error("Invalid wallet id");if(!this.activeAdapters.has(r))throw new Error(`Wallet adapter ${t.name} not connected`);let a;try{a=await n.connect(e)}catch{a=!1}return this.update$.next(),a}async disconnect(){if(this.currentActiveAdapter===null)return!0;try{const t=await this.currentActiveAdapter.disconnect();return this.currentActiveAdapterId&&this.activeAdapters.delete(this.currentActiveAdapterId),this.currentActiveAdapterId&&st(this.currentActiveAdapterId),this.currentActiveAdapterId=null,this.update$.next(),t}catch(t){return console.error(t),!1}}async changeChain(t){let e=!0;if(this.currentActiveAdapter)try{e=await this.currentActiveAdapter.changeChain(t)}catch{e=!1}return e&&this.data.setChainId(t),e}getDataAdapter(t){const e=o(t),r=this.adapters.get(e);if(!r)throw new Error(`Invalid wallet info ${t.name} not exist`);return r.data}async setActiveAddress(t,e){const r=o(t);return await this.setActiveAddressInner(r,e)}async writeContract(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.writeContract(t)}async signTypedData(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.signTypedData(t)}async setActiveAddressInner(t,e){var n;let r=!0;if(this.currentActiveAdapterId!==t){const a=await this.data.getChainId();if(!this.adapters.has(t))throw new Error("Invalid wallet not exist");r=await this.connectSafe(a,t),this.afterConnectWallet(r,t)}r&&((n=this.currentActiveAdapter)==null||n.setActiveAddress(e)),this.update$.next()}async connectSafe(t,e,r=!1){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(!this.activeAdapters.has(e)||r){try{a=await n.connect(t)}catch{a=!1}a&&this.activeAdapters.set(e,n)}else a=await n.isConnected(),!r&&!a&&(a=await this.connectSafe(t,e,!0));return a}async restoreConnectSafe(t,e,r){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(this.activeAdapters.has(e))a=await n.isConnected();else{try{a=await n.restoreConnect(t,r)}catch{a=!1}a&&this.activeAdapters.set(e,n)}return a}async restoreChainId(){const t=Dt();t&&await this.changeChain(t)}async restoreWalletConnection(){const t=at(),e=ze();if(!e)return;await this.getSupportedWallets();const r=await this.data.getChainId();for(const i of e){if(i===t||!this.adapters.has(i))continue;const c=await this.restoreConnectSafe(r,i).catch(()=>!1);this.afterConnectWallet(c,i)}if(!t||!this.adapters.has(t))return;const n=await this.restoreConnectSafe(r,t,!0);if(this.afterConnectWallet(n,t),!n)return;const a=xe();!a||!this.currentActiveAdapter||!(await this.currentActiveAdapter.data.getAddresses()).includes(a)||await this.setActiveAddressInner(t,a)}initWallets(){return new Promise(t=>{let e=!1;oe(window,"eip6963:announceProvider").pipe(I(r=>{e=Ue(window.ethereum,r.detail.provider);const n=o(r.detail.info);this.adapters.has(n)||this.adapters.set(n,new k(r.detail))}),ne(100),ue(1),Ct(D(100)),yt(null),I(async()=>{if(!e&&Me()){const a=await L(),s=o(a.info);this.adapters.has(s)||this.adapters.set(s,new k(a))}const r=await ke(),n=o(r.info);this.adapters.set(n,new je(r)),t()})).subscribe(),window.dispatchEvent(new Event("eip6963:requestProvider"))})}afterConnectWallet(t,e){t?(this.currentActiveAdapterId=e,qe(e),nt(e)):(st(e),at()===e&&nt(null),this.currentActiveAdapterId===e&&(this.currentActiveAdapterId=null),this.activeAdapters.has(e)&&(this.adapters.get(e).disconnect().catch(),this.activeAdapters.delete(e)))}};function Ue(t,e){if(t===e)return!0;const r=Object.keys(t??{}),n=Object.keys(e??{});if(r.length!==n.length)return!1;for(const a of r)if(t[a]!==e[a])return!1;return!0}function tr(){return new Fe}var er=class{constructor(t){this.config=t,this.currentActiveAdapter=null,this.activeAdapters=new Map,this.data=new Wt(this),this.update$=new vt}get isConnected(){return!0}async init(){if(!this.config.walletProvider)return;const t=await L(this.config.walletProvider),e=o(t.info),r=new k(t);this.activeAdapters.set(e,r),await r.connect(this.config.chainId),this.currentActiveAdapter=r,this.update$.next()}async getSupportedWallets(){return[(await L(this.config.walletProvider)).info]}async writeContract(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.writeContract(t)}async signTypedData(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.signTypedData(t)}async changeChain(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.changeChain(t)}connect(t){throw new Error("Method not implemented.")}addConnection(t){throw new Error("Method not implemented.")}disconnect(){throw new Error("Method not implemented.")}getDataAdapter(t){throw new Error("Method not implemented.")}setActiveAddress(t,e){throw new Error("Method not implemented.")}};export{er as ConnectWalletEmbeddedController,tr as createConnectWalletController,Dt as getChainIdFromStorage};
//# sourceMappingURL=index.esm-BjCDpKe2.js.map
