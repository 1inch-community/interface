const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/multi-connect-provider-YOTZYVBH-xZK148ZQ.js","assets/index-DuIRcoZI.js","assets/index.esm-DhwY4kHm.js","assets/import-wrapper-prod-hit9ecK7.js","assets/index.esm-COc-PyqV.js","assets/index.esm-5Aerb1sL.js","assets/index.esm-bwXoXU4_.js","assets/tap-DGvjHJum.js"])))=>i.map(i=>d[i]);
import{_ as $}from"./index-DuIRcoZI.js";import{E as Tt,B as N,C as St,t as bt,u as _t,v as xt,T as qt,x as it,y as zt,z as I,A as F,D as ct,F as Mt,G as ot,H as Ot,I as dt,J as E,K as Rt,M as jt,N as b,O as kt,P as Lt,Q as ut,R as Nt,S as Ft,V as _,W as ht,X as Ut,Y as Bt,Z as Vt,_ as Ht,$ as Gt,a0 as Jt,a1 as Yt,a2 as Kt,a3 as Qt,a4 as Xt,a5 as Zt,a6 as te,a7 as ee,a8 as re,d as ne,s as h,o as w,a9 as X,aa as S,b as ae,g as lt,m as se}from"./index.esm-bwXoXU4_.js";import{O as pt,d as ie,o as ft,c as wt,S as At,C as ce,s as M,m as A,a as p,e as oe,f as de,b as Z}from"./index.esm-DhwY4kHm.js";import{storage as l}from"./index.esm-COc-PyqV.js";import{B as O,c as T}from"./combineLatest-Bzt_9bb6.js";import{d as vt}from"./defer-BRewiDsk.js";import{f as gt,t as Ct}from"./takeUntil-B9okj2Im.js";import{t as P}from"./tap-DGvjHJum.js";import{a as ue}from"./asap-D-qxMtYG.js";import{f as R}from"./firstValueFrom-RTAQ66ca.js";function tt(t,e){var r=ie(t)?t:function(){return t},n=function(a){return a.error(r())};return new pt(n)}function mt(t){return ft(function(e,r){var n=!1;e.subscribe(wt(r,function(a){n=!0,r.next(a)},function(){n||r.next(t),r.complete()}))})}function he(t){return t<=0?function(){return Tt}:ft(function(e,r){var n=0;e.subscribe(wt(r,function(a){++n<=t&&(r.next(a),t<=n&&r.complete())}))})}class D extends N{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:e,docsSlug:"account",name:"AccountNotFoundError"})}}class x extends N{constructor({docsPath:e,metaMessages:r,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:e,metaMessages:r,name:"AccountTypeNotSupportedError"})}}function yt({chain:t,currentChainId:e}){if(!t)throw new St;if(e!==t.id)throw new bt({chain:t,currentChainId:e})}function le(t,{docsPath:e,...r}){const n=(()=>{const a=_t(t,r);return a instanceof xt?t:a})();return new qt(n,{docsPath:e,...r})}async function U(t,e){var G,J,Y,K;const{account:r=t.account,chain:n=t.chain,accessList:a,authorizationList:s,blobs:i,data:c,gas:d,gasPrice:u,maxFeePerBlobGas:v,maxFeePerGas:g,maxPriorityFeePerGas:m,nonce:B,value:V,...H}=e;if(!r)throw new D({docsPath:"/docs/actions/wallet/sendTransaction"});const f=E(r);try{it(e);const C=await(async()=>{if(e.to)return e.to;if(s&&s.length>0)return await zt({authorization:s[0]}).catch(()=>{throw new N("`to` is required. Could not infer from `authorizationList`.")})})();if(f.type==="json-rpc"){let y;n!==null&&(y=await I(t,F,"getChainId")({}),yt({currentChainId:y,chain:n}));const W=(Y=(J=(G=t.chain)==null?void 0:G.formatters)==null?void 0:J.transactionRequest)==null?void 0:Y.format,Wt=(W||ct)({...Mt(H,{format:W}),accessList:a,authorizationList:s,blobs:i,chainId:y,data:c,from:f.address,gas:d,gasPrice:u,maxFeePerBlobGas:v,maxFeePerGas:g,maxPriorityFeePerGas:m,nonce:B,to:C,value:V});return await t.request({method:"eth_sendTransaction",params:[Wt]},{retryCount:0})}if(f.type==="local"){const y=await I(t,ot,"prepareTransactionRequest")({account:f,accessList:a,authorizationList:s,blobs:i,chain:n,data:c,gas:d,gasPrice:u,maxFeePerBlobGas:v,maxFeePerGas:g,maxPriorityFeePerGas:m,nonce:B,nonceManager:f.nonceManager,parameters:[...Ot,"sidecars"],value:V,...H,to:C}),W=(K=n==null?void 0:n.serializers)==null?void 0:K.transaction,Q=await f.signTransaction(y,{serializer:W});return await I(t,dt,"sendRawTransaction")({serializedTransaction:Q})}throw f.type==="smart"?new x({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new x({docsPath:"/docs/actions/wallet/sendTransaction",type:f.type})}catch(C){throw C instanceof x?C:le(C,{...e,account:f,chain:e.chain||void 0})}}async function pe(t,e){const{abi:r,account:n=t.account,address:a,args:s,dataSuffix:i,functionName:c,...d}=e;if(!n)throw new D({docsPath:"/docs/contract/writeContract"});const u=E(n),v=Rt({abi:r,args:s,functionName:c});try{return await I(t,U,"sendTransaction")({data:`${v}${i?i.replace("0x",""):""}`,to:a,account:u,...d})}catch(g){throw jt(g,{abi:r,address:a,args:s,docsPath:"/docs/contract/writeContract",functionName:c,sender:u.address})}}async function fe(t,{chain:e}){const{id:r,name:n,nativeCurrency:a,rpcUrls:s,blockExplorers:i}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:b(r),chainName:n,nativeCurrency:a,rpcUrls:s.default.http,blockExplorerUrls:i?Object.values(i).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function we(t,e={}){const{key:r="custom",name:n="Custom Provider",retryDelay:a}=e;return({retryCount:s})=>kt({key:r,name:n,request:t.request.bind(t),retryCount:e.retryCount??s,retryDelay:a,type:"custom"})}function Ae(t,e){if(t.length!==e.length)throw new Lt({expectedLength:t.length,givenLength:e.length});const r=[];for(let n=0;n<t.length;n++){const a=t[n],s=e[n];r.push(It(a,s))}return ut(r)}function It(t,e,r=!1){if(t==="address"){const i=e;if(!Nt(i))throw new Ft({address:i});return _(i.toLowerCase(),{size:r?32:null})}if(t==="string")return ht(e);if(t==="bytes")return e;if(t==="bool")return _(Ut(e),{size:r?32:1});const n=t.match(Bt);if(n){const[i,c,d="256"]=n,u=Number.parseInt(d)/8;return b(e,{size:r?32:u,signed:c==="int"})}const a=t.match(Vt);if(a){const[i,c]=a;if(Number.parseInt(c)!==(e.length-2)/2)throw new Ht({expectedSize:Number.parseInt(c),givenSize:(e.length-2)/2});return _(e,{dir:"right",size:r?32:null})}const s=t.match(Gt);if(s&&Array.isArray(e)){const[i,c]=s,d=[];for(let u=0;u<e.length;u++)d.push(It(c,e[u],!0));return d.length===0?"0x":ut(d)}throw new Jt(t)}function ve(t,e){const{abi:r,args:n,bytecode:a,...s}=e,i=Yt({abi:r,args:n,bytecode:a});return U(t,{...s,data:i})}async function ge(t){var r;return((r=t.account)==null?void 0:r.type)==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(n=>Kt(n))}async function Ce(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}async function me(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(r=>Qt(r))}async function ye(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}async function Ie(t,{account:e=t.account,message:r}){if(!e)throw new D({docsPath:"/docs/actions/wallet/signMessage"});const n=E(e);if(n.signMessage)return n.signMessage({message:r});const a=typeof r=="string"?ht(r):r.raw instanceof Uint8Array?Xt(r.raw):r.raw;return t.request({method:"personal_sign",params:[a,n.address]},{retryCount:0})}async function Pe(t,e){var u,v,g,m;const{account:r=t.account,chain:n=t.chain,...a}=e;if(!r)throw new D({docsPath:"/docs/actions/wallet/signTransaction"});const s=E(r);it({account:s,...e});const i=await I(t,F,"getChainId")({});n!==null&&yt({currentChainId:i,chain:n});const c=(n==null?void 0:n.formatters)||((u=t.chain)==null?void 0:u.formatters),d=((v=c==null?void 0:c.transactionRequest)==null?void 0:v.format)||ct;return s.signTransaction?s.signTransaction({...a,chainId:i},{serializer:(m=(g=t.chain)==null?void 0:g.serializers)==null?void 0:m.transaction}):await t.request({method:"eth_signTransaction",params:[{...d(a),chainId:b(i),from:s.address}]},{retryCount:0})}async function $e(t,e){const{account:r=t.account,domain:n,message:a,primaryType:s}=e;if(!r)throw new D({docsPath:"/docs/actions/wallet/signTypedData"});const i=E(r),c={EIP712Domain:Zt({domain:n}),...e.types};if(te({domain:n,message:a,primaryType:s,types:c}),i.signTypedData)return i.signTypedData({domain:n,message:a,primaryType:s,types:c});const d=ee({domain:n,message:a,primaryType:s,types:c});return t.request({method:"eth_signTypedData_v4",params:[i.address,d]},{retryCount:0})}async function Ee(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:b(e)}]},{retryCount:0})}async function De(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}function We(t){return{addChain:e=>fe(t,e),deployContract:e=>ve(t,e),getAddresses:()=>ge(t),getChainId:()=>F(t),getPermissions:()=>Ce(t),prepareTransactionRequest:e=>ot(t,e),requestAddresses:()=>me(t),requestPermissions:e=>ye(t,e),sendRawTransaction:e=>dt(t,e),sendTransaction:e=>U(t,e),signMessage:e=>Ie(t,e),signTransaction:e=>Pe(t,e),signTypedData:e=>$e(t,e),switchChain:e=>Ee(t,e),watchAsset:e=>De(t,e),writeContract:e=>pe(t,e)}}function Te(t){const{key:e="wallet",name:r="Wallet Client",transport:n}=t;return re({...t,key:e,name:r,transport:n,type:"walletClient"}).extend(We)}async function j(t,e,r){const n=Pt(t,e,r);await n.requestAddresses().catch(s=>{var i,c;if(s.core===4001||(c=(i=s.message)==null?void 0:i.toLowerCase())!=null&&c.includes("user reject")||s.details==="Cancelled")throw s});const a=await n.getChainId();return t!==a&&await n.switchChain(lt(t)),n}function Pt(t,e,r){return Te({chain:lt(t),transport:we(e),account:r})}function q(t,e){return new pt(r=>{const n=a=>{r.next(a)};return t.on(e,n),()=>{if("removeListener"in t)return t.removeListener(e,n);console.warn("unable to unsubscribe from provider",t,e)}})}var $t=class{constructor(t){this.info=t,this.provider$=new O(null),this.activeAddressInner$=new O(null),this.providerOrDisconnect$=se(this.provider$,vt(()=>this.disconnect$).pipe(A(()=>null))),this.addresses$=this.providerOrDisconnect$.pipe(h(e=>e?Z(this.getAddresses()).pipe(h(r=>q(e,"accountsChanged").pipe(M(r)))):w([])),p({bufferSize:1,refCount:!0})),this.activeAddress$=T([this.addresses$,this.activeAddressInner$]).pipe(A(([e,r])=>r||e[0]),p({bufferSize:1,refCount:!0})),this.chainId$=this.providerOrDisconnect$.pipe(h(e=>e?Z(this.getChainId()).pipe(h(r=>q(e,"chainChanged").pipe(A(n=>et(n)),M(r)))):w(null)),p({bufferSize:1,refCount:!0})),this.disconnect$=this.provider$.pipe(gt(Boolean),h(e=>q(e,"disconnect"))),this.isConnected$=this.activeAddress$.pipe(A(e=>!!e)),this.info$=w(t)}getInfo(){return this.info}setProvider(t){this.provider$.next(t)}async getAddresses(){const t=this.provider$.value;return t?await t.request({method:"eth_accounts"}):[]}async getActiveAddress(){const t=this.activeAddressInner$.value;return t||((await this.getAddresses())[0]??null)}async getChainId(){const t=this.provider$.value;if(!t)return null;const e=await t.request({method:"eth_chainId"}).catch(()=>null);return e?et(e):null}async isConnected(){return!!await this.getActiveAddress()}setActiveAddress(t){this.activeAddressInner$.next(t)}};function et(t){return typeof t=="number"?t:parseInt(t,16)}function Se(t){const{code:e,message:r}=t;return e===4001||(r==null?void 0:r.toLowerCase().includes("user rejected"))}var k=class{constructor(t){this.providerDetail=t,this.client=null,this.data=new $t(this.providerDetail.info)}async connect(t){return this.client=await j(t,this.providerDetail.provider),this.data.setProvider(this.providerDetail.provider),!0}async restoreConnect(t,e){this.data.setProvider(this.providerDetail.provider);const n=(await this.data.getAddresses()).length>0&&t!==null;return n?this.client=Pt(t,this.providerDetail.provider):this.data.setProvider(null),!n&&e?this.connect(t):n}async disconnect(){return this.client=null,this.data.setProvider(null),!0}async changeChain(t){return this.client?(await this.client.switchChain({id:t}),!0):!1}async isConnected(){var e;return(await((e=this.client)==null?void 0:e.getAddresses())??[]).length>0}setActiveAddress(t){this.data.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await this.client.writeContract({...t,account:e})}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();try{return await this.client.signTypedData({...t,account:e})}catch(n){if(Se(n))throw n;console.log(n)}const r=JSON.stringify(t,be);return await this.providerDetail.provider.request({method:"eth_signTypedData_v3",params:[e,r]})}};function be(t,e){return typeof e=="bigint"?e.toString():e}function _e(t){l.set("chainId",Number(t))}function Et(){return l.get("chainId",Number)}function xe(t){l.set("activeAddress",t)}function qe(){return l.get("activeAddress",String)}function rt(t){l.set("activeWallet",t)}function nt(){return l.get("activeWallet",String)}function ze(t){const e=l.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)||(r.add(t),l.set("connectedWallet",[...r.keys()]))}function Me(){return l.get("connectedWallet",JSON.parse)}function at(t){const e=l.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)&&(r.delete(t),l.set("connectedWallet",[...r.keys()]))}var z=new WeakMap;function o(t){if(z.has(t))return z.get(t);const e=Ae(["string","string","string"],[t.name,t.rdns??"",t.icon]).slice(0,10);return z.set(t,e),e}var Dt=class{constructor(t){this.dataProvider=t,this.chainIdInner$=new O(Et()??ce.eth),this.currentActiveAdapter$=vt(()=>this.dataProvider.update$).pipe(M(null),A(()=>this.dataProvider.currentActiveAdapter),ne(),p({bufferSize:1,refCount:!0})),this.currentActiveAdapterData$=this.currentActiveAdapter$.pipe(A(e=>(e==null?void 0:e.data)??null),p({bufferSize:1,refCount:!0})),this.info$=this.currentActiveAdapterData$.pipe(gt(Boolean),h(e=>e.info$)),this.addresses$=this.currentActiveAdapterData$.pipe(h(e=>(e==null?void 0:e.addresses$)??w([])),P(e=>console.log(e)),p({bufferSize:1,refCount:!0})),this.activeAddress$=this.currentActiveAdapterData$.pipe(h(e=>(e==null?void 0:e.activeAddress$)??w(null)),P(e=>e&&xe(e)),p({bufferSize:1,refCount:!0})),this.chainId$=T([this.currentActiveAdapterData$,this.chainIdInner$]).pipe(h(([e,r])=>(e==null?void 0:e.chainId$)??w(r)),P(e=>e&&_e(e)),p({bufferSize:1,refCount:!0})),this.disconnect$=this.currentActiveAdapterData$.pipe(h(e=>(e==null?void 0:e.disconnect$)??w()),p({bufferSize:1,refCount:!0})),this.isConnected$=this.currentActiveAdapterData$.pipe(h(e=>(e==null?void 0:e.isConnected$)??w(!1)),p({bufferSize:1,refCount:!0})),T([this.activeAddress$,this.chainId$]).pipe(oe(ue)).subscribe()}getInfo(){if(!this.dataProvider.currentActiveAdapter)throw new Error("");return this.dataProvider.currentActiveAdapter.data.getInfo()}async getAddresses(){const t=await this.getProviderDataAdapter();return t?await t.getAddresses():[]}async getActiveAddress(){if(!this.dataProvider.currentActiveAdapter)return null;const t=await this.getProviderDataAdapter();return t?await t.getActiveAddress():null}async getChainId(){if(!this.dataProvider.currentActiveAdapter)return this.chainIdInner$.value;const t=await this.getProviderDataAdapter();if(!t)return this.chainIdInner$.value;const e=await t.getChainId();return e||this.chainIdInner$.value}async isConnected(){if(!this.dataProvider.currentActiveAdapter)return!1;const t=await this.getProviderDataAdapter();return t?await t.isConnected():!1}async isActiveAddress(t,e){var i,c;const r=o(t),n=await((i=this.dataProvider.currentActiveAdapter)==null?void 0:i.data.getActiveAddress())??null,a=((c=this.dataProvider.currentActiveAdapter)==null?void 0:c.data.getInfo())??null,s=a?o(a):null;return!!n&&!!s&&r===s&&X(n,e)}isActiveWallet(t){var a;const e=o(t),r=((a=this.dataProvider.currentActiveAdapter)==null?void 0:a.data.getInfo())??null,n=r?o(r):null;return!!n&&n===e}isActiveAddress$(t,e){const r=o(t);return T([this.currentActiveAdapter$,this.activeAddress$]).pipe(A(([n,a])=>{const s=n?o(n.data.getInfo()):null;return!!a&&!!s&&r===s&&X(a,e)}))}isActiveWallet$(t){const e=o(t);return this.currentActiveAdapter$.pipe(A(r=>{const n=r?o(r.data.getInfo()):null;return!!n&&n===e}))}setChainId(t){this.chainIdInner$.next(t)}getProviderDataAdapter(){return R(this.currentActiveAdapterData$.pipe(Ct(S(0)),mt(null)))}};function Oe(){return!!window.ethereum}async function L(t=window.ethereum){if(!t)throw new Error("injected provider not supported");return{provider:t,info:{walletId:"injectedWalletId",uuid:"injectedWallet",name:je(),icon:await Re()}}}var st={default:()=>$(()=>import("./default-icon-UF676TO4-57bNFlKZ.js"),[]).then(t=>t.icon),oneInchWallet:()=>$(()=>import("./one-inch-wallet-icon-5SPUNDFK-BHiOEM79.js"),[]).then(t=>t.icon)};function Re(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?st.oneInchWallet():st.default()}function je(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?"1inch wallet":"Browser wallet"}var ke=class{constructor(t){this.providerDetail=t,this.provider=null,this.client=null,this.data=new $t(this.providerDetail.info)}async isConnected(){var t;return((t=this.provider)==null?void 0:t.isConnected())??!1}async connect(t){if(this.provider)await this.provider.connect();else{const e=await $(()=>import("./multi-connect-provider-YOTZYVBH-xZK148ZQ.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(r=>r.MultiConnectProvider.connect());this.client=await j(t,e),this.data.setProvider(e),this.provider=e}return!0}async restoreConnect(){if(this.provider)await this.provider.restoreConnect();else{const t=await $(()=>import("./multi-connect-provider-YOTZYVBH-xZK148ZQ.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(e=>e.MultiConnectProvider.restoreConnect());this.client=await j(t.chainId,t),this.data.setProvider(t),this.provider=t}return!0}async disconnect(){var t;return(t=this.provider)==null||t.disconnect(),!0}async changeChain(t){var e;return await((e=this.client)==null?void 0:e.switchChain({id:t})),!0}setActiveAddress(t){var e;(e=this.provider)==null||e.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.any([this.client.writeContract({...t,account:e}),R(S(60*1e3*3).pipe(h(()=>tt(()=>new Error("wallet connect request timed out")))))])}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.race([this.client.signTypedData({...t,account:e}),R(S(60*1e3*3).pipe(h(()=>tt(()=>new Error("wallet connect request timed out")))))])}};async function Le(){return{info:{walletId:"walletConnectId",uuid:"walletConnect",name:"Wallet Connect",icon:await Fe()}}}var Ne={default:()=>$(()=>import("./wallet-connect-icon-NJ76IV67-lPk-W8Bs.js"),[]).then(t=>t.icon)};function Fe(){return Ne.default()}var Ue=class{constructor(){this.data=new Dt(this),this.activeAdapters=new Map,this.update$=new At,this.currentActiveAdapterId=null,this.adapters=new Map}get isConnected(){return this.currentActiveAdapter!==null}get currentActiveAdapter(){return this.currentActiveAdapterId?this.activeAdapters.get(this.currentActiveAdapterId)??null:null}async init(){await this.initWallets(),await this.restoreChainId(),await this.restoreWalletConnection(),this.update$.next()}async getSupportedWallets(){const t=[];return this.adapters.forEach(e=>t.push(e.data.getInfo())),t.sort((e,r)=>{const n=o(e),a=o(r);return n===this.currentActiveAdapterId&&a!==this.currentActiveAdapterId?-1:n!==this.currentActiveAdapterId&&a===this.currentActiveAdapterId?1:this.activeAdapters.has(n)&&this.activeAdapters.has(a)?0:this.activeAdapters.has(n)&&!this.activeAdapters.has(a)?-1:!this.activeAdapters.has(n)&&this.activeAdapters.has(a)?1:0})}async connect(t){const e=await this.data.getChainId(),r=o(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=await this.connectSafe(e,r);return this.afterConnectWallet(n,r),this.update$.next(),n}async addConnection(t){const e=await this.data.getChainId(),r=o(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=this.adapters.get(r);if(!n)throw new Error("Invalid wallet id");if(!this.activeAdapters.has(r))throw new Error(`Wallet adapter ${t.name} not connected`);let a;try{a=await n.connect(e)}catch{a=!1}return this.update$.next(),a}async disconnect(){if(this.currentActiveAdapter===null)return!0;try{const t=await this.currentActiveAdapter.disconnect();return this.currentActiveAdapterId&&this.activeAdapters.delete(this.currentActiveAdapterId),this.currentActiveAdapterId&&at(this.currentActiveAdapterId),this.currentActiveAdapterId=null,this.update$.next(),t}catch(t){return console.error(t),!1}}async changeChain(t){let e=!0;if(this.currentActiveAdapter)try{e=await this.currentActiveAdapter.changeChain(t)}catch{e=!1}return e&&this.data.setChainId(t),e}getDataAdapter(t){const e=o(t),r=this.adapters.get(e);if(!r)throw new Error(`Invalid wallet info ${t.name} not exist`);return r.data}async setActiveAddress(t,e){const r=o(t);return await this.setActiveAddressInner(r,e)}async writeContract(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.writeContract(t)}async signTypedData(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.signTypedData(t)}async setActiveAddressInner(t,e){var n;let r=!0;if(this.currentActiveAdapterId!==t){const a=await this.data.getChainId();if(!this.adapters.has(t))throw new Error("Invalid wallet not exist");r=await this.connectSafe(a,t),this.afterConnectWallet(r,t)}r&&((n=this.currentActiveAdapter)==null||n.setActiveAddress(e)),this.update$.next()}async connectSafe(t,e,r=!1){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(!this.activeAdapters.has(e)||r){try{a=await n.connect(t)}catch{a=!1}a&&this.activeAdapters.set(e,n)}else a=await n.isConnected(),!r&&!a&&(a=await this.connectSafe(t,e,!0));return a}async restoreConnectSafe(t,e,r){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(this.activeAdapters.has(e))a=await n.isConnected();else{try{a=await n.restoreConnect(t,r)}catch{a=!1}a&&this.activeAdapters.set(e,n)}return a}async restoreChainId(){const t=Et();t&&await this.changeChain(t)}async restoreWalletConnection(){const t=nt(),e=Me();if(!e)return;await this.getSupportedWallets();const r=await this.data.getChainId();for(const i of e){if(i===t||!this.adapters.has(i))continue;const c=await this.restoreConnectSafe(r,i).catch(()=>!1);this.afterConnectWallet(c,i)}if(!t||!this.adapters.has(t))return;const n=await this.restoreConnectSafe(r,t,!0);if(this.afterConnectWallet(n,t),!n)return;const a=qe();!a||!this.currentActiveAdapter||!(await this.currentActiveAdapter.data.getAddresses()).includes(a)||await this.setActiveAddressInner(t,a)}initWallets(){return new Promise(t=>{let e=!1;de(window,"eip6963:announceProvider").pipe(P(r=>{e=Be(window.ethereum,r.detail.provider);const n=o(r.detail.info);this.adapters.has(n)||this.adapters.set(n,new k(r.detail))}),ae(100),he(1),Ct(S(100)),mt(null),P(async()=>{if(!e&&Oe()){const a=await L(),s=o(a.info);this.adapters.has(s)||this.adapters.set(s,new k(a))}const r=await Le(),n=o(r.info);this.adapters.set(n,new ke(r)),t()})).subscribe(),window.dispatchEvent(new Event("eip6963:requestProvider"))})}afterConnectWallet(t,e){t?(this.currentActiveAdapterId=e,ze(e),rt(e)):(at(e),nt()===e&&rt(null),this.currentActiveAdapterId===e&&(this.currentActiveAdapterId=null),this.activeAdapters.has(e)&&(this.adapters.get(e).disconnect().catch(),this.activeAdapters.delete(e)))}};function Be(t,e){if(t===e)return!0;const r=Object.keys(t??{}),n=Object.keys(e??{});if(r.length!==n.length)return!1;for(const a of r)if(t[a]!==e[a])return!1;return!0}function er(){return new Ue}var rr=class{constructor(t){this.config=t,this.currentActiveAdapter=null,this.activeAdapters=new Map,this.data=new Dt(this),this.update$=new At}get isConnected(){return!0}async init(){if(!this.config.walletProvider)return;const t=await L(this.config.walletProvider),e=o(t.info),r=new k(t);this.activeAdapters.set(e,r),await r.connect(this.config.chainId),this.currentActiveAdapter=r,this.update$.next()}async getSupportedWallets(){return[(await L(this.config.walletProvider)).info]}async writeContract(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.writeContract(t)}async signTypedData(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.signTypedData(t)}async changeChain(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.changeChain(t)}connect(t){throw new Error("Method not implemented.")}addConnection(t){throw new Error("Method not implemented.")}disconnect(){throw new Error("Method not implemented.")}getDataAdapter(t){throw new Error("Method not implemented.")}setActiveAddress(t,e){throw new Error("Method not implemented.")}};export{rr as ConnectWalletEmbeddedController,er as createConnectWalletController,Et as getChainIdFromStorage};
//# sourceMappingURL=index.esm-BfLwUXkp.js.map
