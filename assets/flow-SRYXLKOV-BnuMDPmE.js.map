{"version":3,"file":"flow-SRYXLKOV-BnuMDPmE.js","sources":["../../../libs/ui-components/scroll/flow-SRYXLKOV.js"],"sourcesContent":["import \"./chunk-CFVQSSMR.js\";\n\n// node_modules/.pnpm/@lit-labs+virtualizer@2.0.13/node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\nvar SizeCache = class {\n  constructor(config) {\n    this._map = /* @__PURE__ */ new Map();\n    this._roundAverageSize = false;\n    this.totalSize = 0;\n    if (config?.roundAverageSize === true) {\n      this._roundAverageSize = true;\n    }\n  }\n  set(index, value) {\n    const prev = this._map.get(index) || 0;\n    this._map.set(index, value);\n    this.totalSize += value - prev;\n  }\n  get averageSize() {\n    if (this._map.size > 0) {\n      const average = this.totalSize / this._map.size;\n      return this._roundAverageSize ? Math.round(average) : average;\n    }\n    return 0;\n  }\n  getSize(index) {\n    return this._map.get(index);\n  }\n  clear() {\n    this._map.clear();\n    this.totalSize = 0;\n  }\n};\n\n// node_modules/.pnpm/@lit-labs+virtualizer@2.0.13/node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\nfunction dim1(direction) {\n  return direction === \"horizontal\" ? \"width\" : \"height\";\n}\nvar BaseLayout = class {\n  _getDefaultConfig() {\n    return {\n      direction: \"vertical\"\n    };\n  }\n  constructor(hostSink, config) {\n    this._latestCoords = { left: 0, top: 0 };\n    this._direction = null;\n    this._viewportSize = { width: 0, height: 0 };\n    this.totalScrollSize = { width: 0, height: 0 };\n    this.offsetWithinScroller = { left: 0, top: 0 };\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    this._pin = null;\n    this._firstVisible = 0;\n    this._lastVisible = 0;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    this._first = -1;\n    this._last = -1;\n    this._sizeDim = \"height\";\n    this._secondarySizeDim = \"width\";\n    this._positionDim = \"top\";\n    this._secondaryPositionDim = \"left\";\n    this._scrollPosition = 0;\n    this._scrollError = 0;\n    this._items = [];\n    this._scrollSize = 1;\n    this._overhang = 1e3;\n    this._hostSink = hostSink;\n    Promise.resolve().then(() => this.config = config || this._getDefaultConfig());\n  }\n  set config(config) {\n    Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n  }\n  get config() {\n    return {\n      direction: this.direction\n    };\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items() {\n    return this._items;\n  }\n  set items(items) {\n    this._setItems(items);\n  }\n  _setItems(items) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n  /**\n   * Primary scrolling direction.\n   */\n  get direction() {\n    return this._direction;\n  }\n  set direction(dir) {\n    dir = dir === \"horizontal\" ? dir : \"vertical\";\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === \"horizontal\" ? \"width\" : \"height\";\n      this._secondarySizeDim = dir === \"horizontal\" ? \"height\" : \"width\";\n      this._positionDim = dir === \"horizontal\" ? \"left\" : \"top\";\n      this._secondaryPositionDim = dir === \"horizontal\" ? \"top\" : \"left\";\n      this._triggerReflow();\n    }\n  }\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize() {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const { _viewDim1, _viewDim2 } = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll() {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n  set pin(options) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n  get pin() {\n    if (this._pin !== null) {\n      const { index, block } = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block\n      };\n    }\n    return null;\n  }\n  _clampScrollPosition(val) {\n    return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n  }\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n  _updateLayout() {\n  }\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  get _viewDim1() {\n    return this._viewportSize[this._sizeDim];\n  }\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  get _viewDim2() {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n  _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n  _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n  _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const { index, block } = this.pin;\n      this._scrollPosition = this._calculateScrollIntoViewPosition({\n        index,\n        block: block || \"start\"\n      }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  _calculateScrollIntoViewPosition(options) {\n    const { block } = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== \"start\") {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === \"center\") {\n        scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === \"end\") {\n          scrollPosition = itemEndPosition;\n        } else {\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n  getScrollIntoViewCoordinates(options) {\n    return {\n      [this._positionDim]: this._calculateScrollIntoViewPosition(options)\n    };\n  }\n  _sendUnpinnedMessage() {\n    this._hostSink({\n      type: \"unpinned\"\n    });\n  }\n  _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: \"visibilityChanged\",\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible\n    });\n  }\n  _sendStateChangedMessage() {\n    const childPositions = /* @__PURE__ */ new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message = {\n      type: \"stateChanged\",\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null\n      },\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible\n      },\n      childPositions\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0\n      };\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n  /**\n   * Number of items to display.\n   */\n  get _num() {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n  _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({ emit: true });\n      }\n    }\n  }\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  _updateVisibleIndices(options) {\n    if (this._first === -1 || this._last === -1)\n      return;\n    let firstVisible = this._first;\n    while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n      firstVisible++;\n    }\n    let lastVisible = this._last;\n    while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n      lastVisible--;\n    }\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n};\n\n// node_modules/.pnpm/@lit-labs+virtualizer@2.0.13/node_modules/@lit-labs/virtualizer/layouts/flow.js\nvar flow = (config) => Object.assign({\n  type: FlowLayout\n}, config);\nfunction leadingMargin(direction) {\n  return direction === \"horizontal\" ? \"marginLeft\" : \"marginTop\";\n}\nfunction trailingMargin(direction) {\n  return direction === \"horizontal\" ? \"marginRight\" : \"marginBottom\";\n}\nfunction offset(direction) {\n  return direction === \"horizontal\" ? \"xOffset\" : \"yOffset\";\n}\nfunction collapseMargins(a, b) {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nvar MetricsCache = class {\n  constructor() {\n    this._childSizeCache = new SizeCache();\n    this._marginSizeCache = new SizeCache();\n    this._metricsCache = /* @__PURE__ */ new Map();\n  }\n  update(metrics, direction) {\n    const marginsToUpdate = /* @__PURE__ */ new Set();\n    Object.keys(metrics).forEach((key) => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n      const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n  get averageChildSize() {\n    return this._childSizeCache.averageSize;\n  }\n  get totalChildSize() {\n    return this._childSizeCache.totalSize;\n  }\n  get averageMarginSize() {\n    return this._marginSizeCache.averageSize;\n  }\n  get totalMarginSize() {\n    return this._marginSizeCache.totalSize;\n  }\n  getLeadingMarginValue(index, direction) {\n    return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n  }\n  getChildSize(index) {\n    return this._childSizeCache.getSize(index);\n  }\n  getMarginSize(index) {\n    return this._marginSizeCache.getSize(index);\n  }\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n};\nvar FlowLayout = class extends BaseLayout {\n  constructor() {\n    super(...arguments);\n    this._itemSize = { width: 100, height: 100 };\n    this._physicalItems = /* @__PURE__ */ new Map();\n    this._newPhysicalItems = /* @__PURE__ */ new Map();\n    this._metricsCache = new MetricsCache();\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n    this._measureChildren = true;\n    this._estimate = true;\n  }\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n  get measureChildren() {\n    return this._measureChildren;\n  }\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes) {\n    this._metricsCache.update(sizes, this.direction);\n    this._scheduleReflow();\n  }\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n  _getPhysicalItem(idx) {\n    return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n  }\n  _getSize(idx) {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n  _getAverageSize() {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n  _estimatePosition(idx) {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return c.averageMarginSize + idx * (c.averageMarginSize + this._getAverageSize());\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return refItem.pos - (c.getMarginSize(this._first - 1) || c.averageMarginSize) - (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize);\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return refItem.pos + (c.getChildSize(this._last) || c.averageChildSize) + (c.getMarginSize(this._last) || c.averageMarginSize) + delta * (c.averageChildSize + c.averageMarginSize);\n      }\n    }\n  }\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx) {\n    const item = this._getPhysicalItem(idx);\n    const { averageMarginSize } = this._metricsCache;\n    return idx === 0 ? this._metricsCache.getMarginSize(0) ?? averageMarginSize : item ? item.pos : this._estimatePosition(idx);\n  }\n  _calculateAnchor(lower, upper) {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n  }\n  _getAnchor(lower, upper) {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n    if (lastMax < lower) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      return this._calculateAnchor(lower, upper);\n    }\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n    }\n    return candidateIdx;\n  }\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n    if (this.pin !== null) {\n      const { index } = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n    lower = this._scrollPosition - this._overhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang;\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === void 0) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n    const anchorLeadingMargin = this._metricsCache.getMarginSize(this._anchorIdx) ?? this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin = this._metricsCache.getMarginSize(this._anchorIdx + 1) ?? this._metricsCache.averageMarginSize;\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n    let anchorErr = 0;\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n    items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === void 0) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === void 0) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, { pos, size });\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === void 0) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === void 0) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, { pos, size });\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach((item) => item.pos -= extentErr);\n      this._scrollError += extentErr;\n    }\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n  _calculateError() {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return this._physicalMax - this._scrollSize + (this.items.length - 1 - this._last) * this._delta;\n    }\n    return 0;\n  }\n  _reflow() {\n    const { _first, _last } = this;\n    super._reflow();\n    if (this._first === -1 && this._last == -1 || this._first === _first && this._last === _last) {\n      this._resetReflowState();\n    }\n  }\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n  _updateScrollSize() {\n    const { averageMarginSize } = this._metricsCache;\n    this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n  }\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  get _delta() {\n    const { averageMarginSize } = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx) {\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -(this._metricsCache.getLeadingMarginValue(idx, this.direction) ?? this._metricsCache.averageMarginSize)\n    };\n  }\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx) {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim]\n    };\n  }\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n};\nexport {\n  FlowLayout,\n  flow\n};\n//# sourceMappingURL=flow-SRYXLKOV.js.map\n"],"names":["SizeCache","config","index","value","prev","average","dim1","direction","BaseLayout","hostSink","items","dir","dims","_viewDim1","_viewDim2","coords","oldPos","force","options","block","val","lastScrollPosition","itemStartPosition","scrollPosition","itemSize","itemEndPosition","currentScrollPosition","childPositions","idx","message","min","max","firstVisible","lastVisible","flow","FlowLayout","leadingMargin","trailingMargin","offset","collapseMargins","a","b","m","MetricsCache","metrics","_a","_b","marginsToUpdate","key","k","sizes","c","delta","item","averageMarginSize","lower","upper","firstItem","lastItem","firstMin","candidateIdx","cMax","anchorSize","anchorLeadingMargin","anchorTrailingMargin","anchorErr","size","margin","pos","extentErr","_first","_last"],"mappings":"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"}