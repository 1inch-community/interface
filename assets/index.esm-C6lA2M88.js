const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/multi-connect-provider-YOTZYVBH-B3q57GCx.js","assets/index-CD7KJpAO.js","assets/index.esm-DhwY4kHm.js","assets/import-wrapper-prod-BvIURD_x.js","assets/index.esm-COc-PyqV.js","assets/index.esm-5Aerb1sL.js","assets/index.esm-BwrBO1xr.js","assets/tap-DGvjHJum.js"])))=>i.map(i=>d[i]);
import{_ as $}from"./index-CD7KJpAO.js";import{E as Pt,B as at,C as bt,t as Et,u as Dt,v as St,T as Tt,x as st,y,z as j,A as it,D as Wt,F as ct,G as _t,H as ot,I as D,J as xt,K as S,M as qt,N as zt,O as dt,P as Ot,Q as Rt,R as _,S as ut,V as Mt,W as jt,X as kt,Y as Nt,Z as Lt,_ as Ft,$ as Ut,a0 as Bt,a1 as Vt,a2 as Ht,a3 as Gt,a4 as Jt,a5 as Yt,a6 as Kt,b as Qt,a7 as E,d as Xt,s as u,o as A,a8 as J,g as ht,m as Zt}from"./index.esm-BwrBO1xr.js";import{O as lt,d as te,o as pt,c as ft,S as ee,f as re,C as ne,s as z,m as w,a as p,e as ae,b as Y}from"./index.esm-DhwY4kHm.js";import{storage as l}from"./index.esm-COc-PyqV.js";import{t as I}from"./tap-DGvjHJum.js";import{t as At,f as wt}from"./takeUntil-B9okj2Im.js";import{B as O,c as b}from"./combineLatest-Bzt_9bb6.js";import{d as vt}from"./defer-BRewiDsk.js";import{a as se}from"./asap-D-qxMtYG.js";import{f as R}from"./firstValueFrom-RTAQ66ca.js";function K(t,e){var r=te(t)?t:function(){return t},n=function(a){return a.error(r())};return new lt(n)}function gt(t){return pt(function(e,r){var n=!1;e.subscribe(ft(r,function(a){n=!0,r.next(a)},function(){n||r.next(t),r.complete()}))})}function ie(t){return t<=0?function(){return Pt}:pt(function(e,r){var n=0;e.subscribe(ft(r,function(a){++n<=t&&(r.next(a),t<=n&&r.complete())}))})}class T extends at{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:e,docsSlug:"account"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AccountNotFoundError"})}}class Q extends at{constructor({docsPath:e,metaMessages:r,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:e,metaMessages:r}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AccountTypeNotSupportedError"})}}function mt({chain:t,currentChainId:e}){if(!t)throw new bt;if(e!==t.id)throw new Et({chain:t,currentChainId:e})}function ce(t,{docsPath:e,...r}){const n=(()=>{const a=Dt(t,r);return a instanceof St?t:a})();return new Tt(n,{docsPath:e,...r})}async function k(t,e){var U,B,V,H;const{account:r=t.account,chain:n=t.chain,accessList:a,blobs:s,data:i,gas:c,gasPrice:d,maxFeePerBlobGas:h,maxFeePerGas:g,maxPriorityFeePerGas:m,nonce:C,to:N,value:L,...F}=e;if(!r)throw new T({docsPath:"/docs/actions/wallet/sendTransaction"});const v=D(r);try{st(e);let f;if(n!==null&&(f=await y(t,j,"getChainId")({}),mt({currentChainId:f,chain:n})),v.type==="json-rpc"){const P=(V=(B=(U=t.chain)==null?void 0:U.formatters)==null?void 0:B.transactionRequest)==null?void 0:V.format,W=(P||it)({...Wt(F,{format:P}),accessList:a,blobs:s,chainId:f,data:i,from:v.address,gas:c,gasPrice:d,maxFeePerBlobGas:h,maxFeePerGas:g,maxPriorityFeePerGas:m,nonce:C,to:N,value:L});return await t.request({method:"eth_sendTransaction",params:[W]},{retryCount:0})}if(v.type==="local"){const P=await y(t,ct,"prepareTransactionRequest")({account:v,accessList:a,blobs:s,chain:n,chainId:f,data:i,gas:c,gasPrice:d,maxFeePerBlobGas:h,maxFeePerGas:g,maxPriorityFeePerGas:m,nonce:C,parameters:[..._t,"sidecars"],to:N,value:L,...F}),G=(H=n==null?void 0:n.serializers)==null?void 0:H.transaction,W=await v.signTransaction(P,{serializer:G});return await y(t,ot,"sendRawTransaction")({serializedTransaction:W})}throw v.type==="smart"?new Q({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new Error("incompatible account type.")}catch(f){throw f instanceof Q?f:ce(f,{...e,account:v,chain:e.chain||void 0})}}async function oe(t,e){const{abi:r,address:n,args:a,dataSuffix:s,functionName:i,...c}=e,d=xt({abi:r,args:a,functionName:i});return y(t,k,"sendTransaction")({data:`${d}${s?s.replace("0x",""):""}`,to:n,...c})}async function de(t,{chain:e}){const{id:r,name:n,nativeCurrency:a,rpcUrls:s,blockExplorers:i}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:S(r),chainName:n,nativeCurrency:a,rpcUrls:s.default.http,blockExplorerUrls:i?Object.values(i).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function ue(t,e={}){const{key:r="custom",name:n="Custom Provider",retryDelay:a}=e;return({retryCount:s})=>qt({key:r,name:n,request:t.request.bind(t),retryCount:e.retryCount??s,retryDelay:a,type:"custom"})}function he(t,e){if(t.length!==e.length)throw new zt({expectedLength:t.length,givenLength:e.length});const r=[];for(let n=0;n<t.length;n++){const a=t[n],s=e[n];r.push(Ct(a,s))}return dt(r)}function Ct(t,e,r=!1){if(t==="address"){const i=e;if(!Ot(i))throw new Rt({address:i});return _(i.toLowerCase(),{size:r?32:null})}if(t==="string")return ut(e);if(t==="bytes")return e;if(t==="bool")return _(Mt(e),{size:r?32:1});const n=t.match(jt);if(n){const[i,c,d="256"]=n,h=Number.parseInt(d)/8;return S(e,{size:r?32:h,signed:c==="int"})}const a=t.match(kt);if(a){const[i,c]=a;if(Number.parseInt(c)!==(e.length-2)/2)throw new Nt({expectedSize:Number.parseInt(c),givenSize:(e.length-2)/2});return _(e,{dir:"right",size:r?32:null})}const s=t.match(Lt);if(s&&Array.isArray(e)){const[i,c]=s,d=[];for(let h=0;h<e.length;h++)d.push(Ct(c,e[h],!0));return d.length===0?"0x":dt(d)}throw new Ft(t)}function le(t,e){const{abi:r,args:n,bytecode:a,...s}=e,i=Ut({abi:r,args:n,bytecode:a});return k(t,{...s,data:i})}async function pe(t){var r;return((r=t.account)==null?void 0:r.type)==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(n=>Bt(n))}async function fe(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}async function Ae(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(r=>Vt(r))}async function we(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}async function ve(t,{account:e=t.account,message:r}){if(!e)throw new T({docsPath:"/docs/actions/wallet/signMessage"});const n=D(e);if(n.signMessage)return n.signMessage({message:r});const a=typeof r=="string"?ut(r):r.raw instanceof Uint8Array?Ht(r.raw):r.raw;return t.request({method:"personal_sign",params:[a,n.address]},{retryCount:0})}async function ge(t,e){var h,g,m,C;const{account:r=t.account,chain:n=t.chain,...a}=e;if(!r)throw new T({docsPath:"/docs/actions/wallet/signTransaction"});const s=D(r);st({account:s,...e});const i=await y(t,j,"getChainId")({});n!==null&&mt({currentChainId:i,chain:n});const c=(n==null?void 0:n.formatters)||((h=t.chain)==null?void 0:h.formatters),d=((g=c==null?void 0:c.transactionRequest)==null?void 0:g.format)||it;return s.signTransaction?s.signTransaction({...a,chainId:i},{serializer:(C=(m=t.chain)==null?void 0:m.serializers)==null?void 0:C.transaction}):await t.request({method:"eth_signTransaction",params:[{...d(a),chainId:S(i),from:s.address}]},{retryCount:0})}async function me(t,e){const{account:r=t.account,domain:n,message:a,primaryType:s}=e;if(!r)throw new T({docsPath:"/docs/actions/wallet/signTypedData"});const i=D(r),c={EIP712Domain:Gt({domain:n}),...e.types};if(Jt({domain:n,message:a,primaryType:s,types:c}),i.signTypedData)return i.signTypedData({domain:n,message:a,primaryType:s,types:c});const d=Yt({domain:n,message:a,primaryType:s,types:c});return t.request({method:"eth_signTypedData_v4",params:[i.address,d]},{retryCount:0})}async function Ce(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:S(e)}]},{retryCount:0})}async function ye(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}function Ie(t){return{addChain:e=>de(t,e),deployContract:e=>le(t,e),getAddresses:()=>pe(t),getChainId:()=>j(t),getPermissions:()=>fe(t),prepareTransactionRequest:e=>ct(t,e),requestAddresses:()=>Ae(t),requestPermissions:e=>we(t,e),sendRawTransaction:e=>ot(t,e),sendTransaction:e=>k(t,e),signMessage:e=>ve(t,e),signTransaction:e=>ge(t,e),signTypedData:e=>me(t,e),switchChain:e=>Ce(t,e),watchAsset:e=>ye(t,e),writeContract:e=>oe(t,e)}}function $e(t){const{key:e="wallet",name:r="Wallet Client",transport:n}=t;return Kt({...t,key:e,name:r,transport:n,type:"walletClient"}).extend(Ie)}async function M(t,e,r){const n=yt(t,e,r);await n.requestAddresses().catch(s=>{var i,c;if(s.core===4001||(c=(i=s.message)==null?void 0:i.toLowerCase())!=null&&c.includes("user reject")||s.details==="Cancelled")throw s});const a=await n.getChainId();return t!==a&&await n.switchChain(ht(t)),n}function yt(t,e,r){return $e({chain:ht(t),transport:ue(e),account:r})}function x(t,e){return new lt(r=>{const n=a=>{r.next(a)};return t.on(e,n),()=>{if("removeListener"in t)return t.removeListener(e,n);console.warn("unable to unsubscribe from provider",t,e)}})}var It=class{constructor(t){this.info=t,this.provider$=new O(null),this.activeAddressInner$=new O(null),this.providerOrDisconnect$=Zt(this.provider$,vt(()=>this.disconnect$).pipe(w(()=>null))),this.addresses$=this.providerOrDisconnect$.pipe(u(e=>e?Y(this.getAddresses()).pipe(u(r=>x(e,"accountsChanged").pipe(z(r)))):A([])),p({bufferSize:1,refCount:!0})),this.activeAddress$=b([this.addresses$,this.activeAddressInner$]).pipe(w(([e,r])=>r||e[0]),p({bufferSize:1,refCount:!0})),this.chainId$=this.providerOrDisconnect$.pipe(u(e=>e?Y(this.getChainId()).pipe(u(r=>x(e,"chainChanged").pipe(w(n=>X(n)),z(r)))):A(null)),p({bufferSize:1,refCount:!0})),this.disconnect$=this.provider$.pipe(wt(Boolean),u(e=>x(e,"disconnect"))),this.isConnected$=this.activeAddress$.pipe(w(e=>!!e)),this.info$=A(t)}getInfo(){return this.info}setProvider(t){this.provider$.next(t)}async getAddresses(){const t=this.provider$.value;return t?await t.request({method:"eth_accounts"}):[]}async getActiveAddress(){const t=this.activeAddressInner$.value;return t||((await this.getAddresses())[0]??null)}async getChainId(){const t=this.provider$.value;if(!t)return null;const e=await t.request({method:"eth_chainId"}).catch(()=>null);return e?X(e):null}async isConnected(){return!!await this.getActiveAddress()}setActiveAddress(t){this.activeAddressInner$.next(t)}};function X(t){return typeof t=="number"?t:parseInt(t,16)}function Pe(t){const{code:e,message:r}=t;return e===4001||(r==null?void 0:r.toLowerCase().includes("user rejected"))}var Z=class{constructor(t){this.providerDetail=t,this.client=null,this.data=new It(this.providerDetail.info)}async connect(t){return this.client=await M(t,this.providerDetail.provider),this.data.setProvider(this.providerDetail.provider),!0}async restoreConnect(t,e){this.data.setProvider(this.providerDetail.provider);const n=(await this.data.getAddresses()).length>0&&t!==null;return n?this.client=yt(t,this.providerDetail.provider):this.data.setProvider(null),!n&&e?this.connect(t):n}async disconnect(){return this.client=null,this.data.setProvider(null),!0}async changeChain(t){return this.client?(await this.client.switchChain({id:t}),!0):!1}async isConnected(){var e;return(await((e=this.client)==null?void 0:e.getAddresses())??[]).length>0}setActiveAddress(t){this.data.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await this.client.writeContract({...t,account:e})}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();try{return await this.client.signTypedData({...t,account:e})}catch(n){if(Pe(n))throw n;console.log(n)}const r=JSON.stringify(t,be);return await this.providerDetail.provider.request({method:"eth_signTypedData_v3",params:[e,r]})}};function be(t,e){return typeof e=="bigint"?e.toString():e}function Ee(t){l.set("chainId",Number(t))}function $t(){return l.get("chainId",Number)}function De(t){l.set("activeAddress",t)}function Se(){return l.get("activeAddress",String)}function tt(t){l.set("activeWallet",t)}function et(){return l.get("activeWallet",String)}function Te(t){const e=l.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)||(r.add(t),l.set("connectedWallet",[...r.keys()]))}function We(){return l.get("connectedWallet",JSON.parse)}function rt(t){const e=l.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)&&(r.delete(t),l.set("connectedWallet",[...r.keys()]))}var q=new WeakMap;function o(t){if(q.has(t))return q.get(t);const e=he(["string","string","string"],[t.name,t.rdns??"",t.icon]).slice(0,10);return q.set(t,e),e}var _e=class{constructor(t){this.dataProvider=t,this.chainIdInner$=new O($t()??ne.eth),this.currentActiveAdapter$=vt(()=>this.dataProvider.update$).pipe(z(null),w(()=>this.dataProvider.currentActiveAdapter),Xt(),p({bufferSize:1,refCount:!0})),this.currentActiveAdapterData$=this.currentActiveAdapter$.pipe(w(e=>(e==null?void 0:e.data)??null),p({bufferSize:1,refCount:!0})),this.info$=this.currentActiveAdapterData$.pipe(wt(Boolean),u(e=>e.info$)),this.addresses$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.addresses$)??A([])),I(e=>console.log(e)),p({bufferSize:1,refCount:!0})),this.activeAddress$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.activeAddress$)??A(null)),I(e=>e&&De(e)),p({bufferSize:1,refCount:!0})),this.chainId$=b([this.currentActiveAdapterData$,this.chainIdInner$]).pipe(u(([e,r])=>(e==null?void 0:e.chainId$)??A(r)),I(e=>e&&Ee(e)),p({bufferSize:1,refCount:!0})),this.disconnect$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.disconnect$)??A()),p({bufferSize:1,refCount:!0})),this.isConnected$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.isConnected$)??A(!1)),p({bufferSize:1,refCount:!0})),b([this.activeAddress$,this.chainId$]).pipe(ae(se)).subscribe()}getInfo(){if(!this.dataProvider.currentActiveAdapter)throw new Error("");return this.dataProvider.currentActiveAdapter.data.getInfo()}async getAddresses(){const t=await this.getProviderDataAdapter();return t?await t.getAddresses():[]}async getActiveAddress(){if(!this.dataProvider.currentActiveAdapter)return null;const t=await this.getProviderDataAdapter();return t?await t.getActiveAddress():null}async getChainId(){if(!this.dataProvider.currentActiveAdapter)return this.chainIdInner$.value;const t=await this.getProviderDataAdapter();if(!t)return this.chainIdInner$.value;const e=await t.getChainId();return e||this.chainIdInner$.value}async isConnected(){if(!this.dataProvider.currentActiveAdapter)return!1;const t=await this.getProviderDataAdapter();return t?await t.isConnected():!1}async isActiveAddress(t,e){var i,c;const r=o(t),n=await((i=this.dataProvider.currentActiveAdapter)==null?void 0:i.data.getActiveAddress())??null,a=((c=this.dataProvider.currentActiveAdapter)==null?void 0:c.data.getInfo())??null,s=a?o(a):null;return!!n&&!!s&&r===s&&J(n,e)}isActiveWallet(t){var a;const e=o(t),r=((a=this.dataProvider.currentActiveAdapter)==null?void 0:a.data.getInfo())??null,n=r?o(r):null;return!!n&&n===e}isActiveAddress$(t,e){const r=o(t);return b([this.currentActiveAdapter$,this.activeAddress$]).pipe(w(([n,a])=>{const s=n?o(n.data.getInfo()):null;return!!a&&!!s&&r===s&&J(a,e)}))}isActiveWallet$(t){const e=o(t);return this.currentActiveAdapter$.pipe(w(r=>{const n=r?o(r.data.getInfo()):null;return!!n&&n===e}))}setChainId(t){this.chainIdInner$.next(t)}getProviderDataAdapter(){return R(this.currentActiveAdapterData$.pipe(At(E(0)),gt(null)))}};function xe(){return!!window.ethereum}async function qe(){if(!window.ethereum)throw new Error("injected provider not supported");return{provider:window.ethereum,info:{walletId:"injectedWalletId",uuid:"injectedWallet",name:Oe(),icon:await ze()}}}var nt={default:()=>$(()=>import("./default-icon-UF676TO4-57bNFlKZ.js"),[]).then(t=>t.icon),oneInchWallet:()=>$(()=>import("./one-inch-wallet-icon-5SPUNDFK-BHMg-Ox7.js"),[]).then(t=>t.icon)};function ze(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?nt.oneInchWallet():nt.default()}function Oe(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?"1inch wallet":"Browser wallet"}var Re=class{constructor(t){this.providerDetail=t,this.provider=null,this.client=null,this.data=new It(this.providerDetail.info)}async isConnected(){var t;return((t=this.provider)==null?void 0:t.isConnected())??!1}async connect(t){if(this.provider)await this.provider.connect();else{const e=await $(()=>import("./multi-connect-provider-YOTZYVBH-B3q57GCx.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(r=>r.MultiConnectProvider.connect());this.client=await M(t,e),this.data.setProvider(e),this.provider=e}return!0}async restoreConnect(){if(this.provider)await this.provider.restoreConnect();else{const t=await $(()=>import("./multi-connect-provider-YOTZYVBH-B3q57GCx.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(e=>e.MultiConnectProvider.restoreConnect());this.client=await M(t.chainId,t),this.data.setProvider(t),this.provider=t}return!0}async disconnect(){var t;return(t=this.provider)==null||t.disconnect(),!0}async changeChain(t){var e;return await((e=this.client)==null?void 0:e.switchChain({id:t})),!0}setActiveAddress(t){var e;(e=this.provider)==null||e.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.any([this.client.writeContract({...t,account:e}),R(E(60*1e3*3).pipe(u(()=>K(()=>new Error("wallet connect request timed out")))))])}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.race([this.client.signTypedData({...t,account:e}),R(E(60*1e3*3).pipe(u(()=>K(()=>new Error("wallet connect request timed out")))))])}};async function Me(){return{info:{walletId:"walletConnectId",uuid:"walletConnect",name:"Wallet Connect",icon:await ke()}}}var je={default:()=>$(()=>import("./wallet-connect-icon-NJ76IV67-lPk-W8Bs.js"),[]).then(t=>t.icon)};function ke(){return je.default()}var Ne=class{constructor(){this.data=new _e(this),this.activeAdapters=new Map,this.update$=new ee,this.currentActiveAdapterId=null,this.adapters=new Map}get isConnected(){return this.currentActiveAdapter!==null}get currentActiveAdapter(){return this.currentActiveAdapterId?this.activeAdapters.get(this.currentActiveAdapterId)??null:null}async init(){await this.initWallets(),await this.restoreChainId(),await this.restoreWalletConnection(),this.update$.next()}async getSupportedWallets(){const t=[];return this.adapters.forEach(e=>t.push(e.data.getInfo())),t.sort((e,r)=>{const n=o(e),a=o(r);return n===this.currentActiveAdapterId&&a!==this.currentActiveAdapterId?-1:n!==this.currentActiveAdapterId&&a===this.currentActiveAdapterId?1:this.activeAdapters.has(n)&&this.activeAdapters.has(a)?0:this.activeAdapters.has(n)&&!this.activeAdapters.has(a)?-1:!this.activeAdapters.has(n)&&this.activeAdapters.has(a)?1:0})}async connect(t){const e=await this.data.getChainId(),r=o(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=await this.connectSafe(e,r);return this.afterConnectWallet(n,r),this.update$.next(),n}async addConnection(t){const e=await this.data.getChainId(),r=o(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=this.adapters.get(r);if(!n)throw new Error("Invalid wallet id");if(!this.activeAdapters.has(r))throw new Error(`Wallet adapter ${t.name} not connected`);let a;try{a=await n.connect(e)}catch{a=!1}return this.update$.next(),a}async disconnect(){if(this.currentActiveAdapter===null)return!0;try{const t=await this.currentActiveAdapter.disconnect();return this.currentActiveAdapterId&&this.activeAdapters.delete(this.currentActiveAdapterId),this.currentActiveAdapterId&&rt(this.currentActiveAdapterId),this.currentActiveAdapterId=null,this.update$.next(),t}catch(t){return console.error(t),!1}}async changeChain(t){let e=!0;if(this.currentActiveAdapter)try{e=await this.currentActiveAdapter.changeChain(t)}catch{e=!1}return e&&this.data.setChainId(t),e}getDataAdapter(t){const e=o(t),r=this.adapters.get(e);if(!r)throw new Error(`Invalid wallet info ${t.name} not exist`);return r.data}async setActiveAddress(t,e){const r=o(t);return await this.setActiveAddressInner(r,e)}async writeContract(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.writeContract(t)}async signTypedData(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.signTypedData(t)}async setActiveAddressInner(t,e){var n;let r=!0;if(this.currentActiveAdapterId!==t){const a=await this.data.getChainId();if(!this.adapters.has(t))throw new Error("Invalid wallet not exist");r=await this.connectSafe(a,t),this.afterConnectWallet(r,t)}r&&((n=this.currentActiveAdapter)==null||n.setActiveAddress(e)),this.update$.next()}async connectSafe(t,e,r=!1){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(!this.activeAdapters.has(e)||r){try{a=await n.connect(t)}catch{a=!1}a&&this.activeAdapters.set(e,n)}else a=await n.isConnected(),!r&&!a&&(a=await this.connectSafe(t,e,!0));return a}async restoreConnectSafe(t,e,r){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(this.activeAdapters.has(e))a=await n.isConnected();else{try{a=await n.restoreConnect(t,r)}catch{a=!1}a&&this.activeAdapters.set(e,n)}return a}async restoreChainId(){const t=$t();t&&await this.changeChain(t)}async restoreWalletConnection(){const t=et(),e=We();if(!e)return;await this.getSupportedWallets();const r=await this.data.getChainId();for(const i of e){if(i===t||!this.adapters.has(i))continue;const c=await this.restoreConnectSafe(r,i).catch(()=>!1);this.afterConnectWallet(c,i)}if(!t||!this.adapters.has(t))return;const n=await this.restoreConnectSafe(r,t,!0);if(this.afterConnectWallet(n,t),!n)return;const a=Se();!a||!this.currentActiveAdapter||!(await this.currentActiveAdapter.data.getAddresses()).includes(a)||await this.setActiveAddressInner(t,a)}initWallets(){return new Promise(t=>{let e=!1;re(window,"eip6963:announceProvider").pipe(I(r=>{e=Le(window.ethereum,r.detail.provider);const n=o(r.detail.info);this.adapters.has(n)||this.adapters.set(n,new Z(r.detail))}),Qt(100),ie(1),At(E(100)),gt(null),I(async()=>{if(!e&&xe()){const a=await qe(),s=o(a.info);this.adapters.has(s)||this.adapters.set(s,new Z(a))}const r=await Me(),n=o(r.info);this.adapters.set(n,new Re(r)),t()})).subscribe(),window.dispatchEvent(new Event("eip6963:requestProvider"))})}afterConnectWallet(t,e){t?(this.currentActiveAdapterId=e,Te(e),tt(e)):(rt(e),et()===e&&tt(null),this.currentActiveAdapterId===e&&(this.currentActiveAdapterId=null),this.activeAdapters.has(e)&&(this.adapters.get(e).disconnect().catch(),this.activeAdapters.delete(e)))}};function Le(t,e){if(t===e)return!0;const r=Object.keys(t??{}),n=Object.keys(e??{});if(r.length!==n.length)return!1;for(const a of r)if(t[a]!==e[a])return!1;return!0}function Xe(){return new Ne}export{Xe as createConnectWalletController,$t as getChainIdFromStorage};
//# sourceMappingURL=index.esm-C6lA2M88.js.map
