const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/multi-connect-provider-SAZA4Z6C-CsQbTFyf.js","assets/index-Cex0AyA1.js","assets/index.esm-DfotAdpM.js","assets/import-wrapper-prod-mRNndFxq.js","assets/index.esm-B264Kqrf.js","assets/index.esm-BKzNpKsj.js","assets/index.esm-COc-PyqV.js","assets/tap-CWNNm5Pt.js"])))=>i.map(i=>d[i]);
import{_ as $}from"./index-Cex0AyA1.js";import{B as Pt,C as Et,o as bt,p as Dt,q as Wt,T as St,r as et,s as y,t as O,u as rt,v as Tt,w as nt,x as at,y as _t,z as b,A as xt,D,E as qt,F as zt,G as st,H as Rt,I as Ot,J as S,K as it,L as kt,M as Mt,N as Lt,O as jt,P as Nt,Q as Ft,R as Bt,S as Ut,V as Vt,W as Ht,X as Gt,Y as Jt,Z as Yt,_ as Kt,$ as H,g as ct}from"./index.esm-B264Kqrf.js";import{O as ot,e as Qt,o as dt,c as ut,S as Xt,f as Zt,C as te,d as ht,s as x,m as A,a as p,g as ee,b as G}from"./index.esm-DfotAdpM.js";import{storage as l}from"./index.esm-COc-PyqV.js";import{t as I}from"./tap-CWNNm5Pt.js";import{E as re,a as ne,t as E,d as ae,s as u,o as f,m as se}from"./index.esm-BKzNpKsj.js";import{t as lt,f as pt}from"./takeUntil-CSuw8jL4.js";import{B as q,c as P}from"./combineLatest-Cx3jWXTV.js";import{a as ie}from"./asap-BqWvnQ_m.js";import{f as z}from"./firstValueFrom-Ch7AjPMY.js";function J(t,e){var r=Qt(t)?t:function(){return t},n=function(a){return a.error(r())};return new ot(n)}function ft(t){return dt(function(e,r){var n=!1;e.subscribe(ut(r,function(a){n=!0,r.next(a)},function(){n||r.next(t),r.complete()}))})}function ce(t){return t<=0?function(){return re}:dt(function(e,r){var n=0;e.subscribe(ut(r,function(a){++n<=t&&(r.next(a),t<=n&&r.complete())}))})}class W extends Pt{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."].join(`
`),{docsPath:e,docsSlug:"account"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AccountNotFoundError"})}}function At({chain:t,currentChainId:e}){if(!t)throw new Et;if(e!==t.id)throw new bt({chain:t,currentChainId:e})}function oe(t,{docsPath:e,...r}){const n=(()=>{const a=Dt(t,r);return a instanceof Wt?t:a})();return new St(n,{docsPath:e,...r})}async function k(t,e){var N,F,B,U;const{account:r=t.account,chain:n=t.chain,accessList:a,blobs:s,data:i,gas:c,gasPrice:d,maxFeePerBlobGas:h,maxFeePerGas:v,maxPriorityFeePerGas:g,nonce:C,to:M,value:L,...j}=e;if(!r)throw new W({docsPath:"/docs/actions/wallet/sendTransaction"});const m=b(r);try{et(e);let w;if(n!==null&&(w=await y(t,O,"getChainId")({}),At({currentChainId:w,chain:n})),m.type==="local"){const yt=await y(t,rt,"prepareTransactionRequest")({account:m,accessList:a,blobs:s,chain:n,chainId:w,data:i,gas:c,gasPrice:d,maxFeePerBlobGas:h,maxFeePerGas:v,maxPriorityFeePerGas:g,nonce:C,parameters:[...Tt,"sidecars"],to:M,value:L,...j}),It=(N=n==null?void 0:n.serializers)==null?void 0:N.transaction,$t=await m.signTransaction(yt,{serializer:It});return await y(t,nt,"sendRawTransaction")({serializedTransaction:$t})}const V=(U=(B=(F=t.chain)==null?void 0:F.formatters)==null?void 0:B.transactionRequest)==null?void 0:U.format,mt=(V||at)({..._t(j,{format:V}),accessList:a,blobs:s,chainId:w,data:i,from:m.address,gas:c,gasPrice:d,maxFeePerBlobGas:h,maxFeePerGas:v,maxPriorityFeePerGas:g,nonce:C,to:M,value:L});return await t.request({method:"eth_sendTransaction",params:[mt]},{retryCount:0})}catch(w){throw oe(w,{...e,account:m,chain:e.chain||void 0})}}async function de(t,e){const{abi:r,address:n,args:a,dataSuffix:s,functionName:i,...c}=e,d=xt({abi:r,args:a,functionName:i});return y(t,k,"sendTransaction")({data:`${d}${s?s.replace("0x",""):""}`,to:n,...c})}async function ue(t,{chain:e}){const{id:r,name:n,nativeCurrency:a,rpcUrls:s,blockExplorers:i}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:D(r),chainName:n,nativeCurrency:a,rpcUrls:s.default.http,blockExplorerUrls:i?Object.values(i).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function he(t,e={}){const{key:r="custom",name:n="Custom Provider",retryDelay:a}=e;return({retryCount:s})=>qt({key:r,name:n,request:t.request.bind(t),retryCount:e.retryCount??s,retryDelay:a,type:"custom"})}function le(t,e){if(t.length!==e.length)throw new zt({expectedLength:t.length,givenLength:e.length});const r=[];for(let n=0;n<t.length;n++){const a=t[n],s=e[n];r.push(wt(a,s))}return st(r)}function wt(t,e,r=!1){if(t==="address"){const i=e;if(!Rt(i))throw new Ot({address:i});return S(i.toLowerCase(),{size:r?32:null})}if(t==="string")return it(e);if(t==="bytes")return e;if(t==="bool")return S(kt(e),{size:r?32:1});const n=t.match(Mt);if(n){const[i,c,d="256"]=n,h=Number.parseInt(d)/8;return D(e,{size:r?32:h,signed:c==="int"})}const a=t.match(Lt);if(a){const[i,c]=a;if(Number.parseInt(c)!==(e.length-2)/2)throw new jt({expectedSize:Number.parseInt(c),givenSize:(e.length-2)/2});return S(e,{dir:"right",size:r?32:null})}const s=t.match(Nt);if(s&&Array.isArray(e)){const[i,c]=s,d=[];for(let h=0;h<e.length;h++)d.push(wt(c,e[h],!0));return d.length===0?"0x":st(d)}throw new Ft(t)}function pe(t,e){const{abi:r,args:n,bytecode:a,...s}=e,i=Bt({abi:r,args:n,bytecode:a});return k(t,{...s,data:i})}async function fe(t){var r;return((r=t.account)==null?void 0:r.type)==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(n=>Ut(n))}async function Ae(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}async function we(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(r=>Vt(r))}async function ve(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}async function ge(t,{account:e=t.account,message:r}){if(!e)throw new W({docsPath:"/docs/actions/wallet/signMessage"});const n=b(e);if(n.type==="local")return n.signMessage({message:r});const a=typeof r=="string"?it(r):r.raw instanceof Uint8Array?Ht(r.raw):r.raw;return t.request({method:"personal_sign",params:[a,n.address]},{retryCount:0})}async function Ce(t,e){var h,v,g,C;const{account:r=t.account,chain:n=t.chain,...a}=e;if(!r)throw new W({docsPath:"/docs/actions/wallet/signTransaction"});const s=b(r);et({account:s,...e});const i=await y(t,O,"getChainId")({});n!==null&&At({currentChainId:i,chain:n});const c=(n==null?void 0:n.formatters)||((h=t.chain)==null?void 0:h.formatters),d=((v=c==null?void 0:c.transactionRequest)==null?void 0:v.format)||at;return s.type==="local"?s.signTransaction({...a,chainId:i},{serializer:(C=(g=t.chain)==null?void 0:g.serializers)==null?void 0:C.transaction}):await t.request({method:"eth_signTransaction",params:[{...d(a),chainId:D(i),from:s.address}]},{retryCount:0})}async function me(t,e){const{account:r=t.account,domain:n,message:a,primaryType:s}=e;if(!r)throw new W({docsPath:"/docs/actions/wallet/signTypedData"});const i=b(r),c={EIP712Domain:Gt({domain:n}),...e.types};if(Jt({domain:n,message:a,primaryType:s,types:c}),i.type==="local")return i.signTypedData({domain:n,message:a,primaryType:s,types:c});const d=Yt({domain:n,message:a,primaryType:s,types:c});return t.request({method:"eth_signTypedData_v4",params:[i.address,d]},{retryCount:0})}async function ye(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:D(e)}]},{retryCount:0})}async function Ie(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}function $e(t){return{addChain:e=>ue(t,e),deployContract:e=>pe(t,e),getAddresses:()=>fe(t),getChainId:()=>O(t),getPermissions:()=>Ae(t),prepareTransactionRequest:e=>rt(t,e),requestAddresses:()=>we(t),requestPermissions:e=>ve(t,e),sendRawTransaction:e=>nt(t,e),sendTransaction:e=>k(t,e),signMessage:e=>ge(t,e),signTransaction:e=>Ce(t,e),signTypedData:e=>me(t,e),switchChain:e=>ye(t,e),watchAsset:e=>Ie(t,e),writeContract:e=>de(t,e)}}function Pe(t){const{key:e="wallet",name:r="Wallet Client",transport:n}=t;return Kt({...t,key:e,name:r,transport:n,type:"walletClient"}).extend($e)}async function R(t,e,r){const n=vt(t,e,r);await n.requestAddresses().catch(s=>{var i,c;if(s.core===4001||(c=(i=s.message)==null?void 0:i.toLowerCase())!=null&&c.includes("user reject")||s.details==="Cancelled")throw s});const a=await n.getChainId();return t!==a&&await n.switchChain(ct(t)),n}function vt(t,e,r){return Pe({chain:ct(t),transport:he(e),account:r})}function T(t,e){return new ot(r=>{const n=a=>{r.next(a)};return t.on(e,n),()=>{if("removeListener"in t)return t.removeListener(e,n);console.warn("unable to unsubscribe from provider",t,e)}})}var gt=class{constructor(t){this.info=t,this.provider$=new q(null),this.activeAddressInner$=new q(null),this.providerOrDisconnect$=se(this.provider$,ht(()=>this.disconnect$).pipe(A(()=>null))),this.addresses$=this.providerOrDisconnect$.pipe(u(e=>e?G(this.getAddresses()).pipe(u(r=>T(e,"accountsChanged").pipe(x(r)))):f([])),p({bufferSize:1,refCount:!0})),this.activeAddress$=P([this.addresses$,this.activeAddressInner$]).pipe(A(([e,r])=>r||e[0]),p({bufferSize:1,refCount:!0})),this.chainId$=this.providerOrDisconnect$.pipe(u(e=>e?G(this.getChainId()).pipe(u(r=>T(e,"chainChanged").pipe(A(n=>Y(n)),x(r)))):f(null)),p({bufferSize:1,refCount:!0})),this.disconnect$=this.provider$.pipe(pt(Boolean),u(e=>T(e,"disconnect"))),this.isConnected$=this.activeAddress$.pipe(A(e=>!!e)),this.info$=f(t)}getInfo(){return this.info}setProvider(t){this.provider$.next(t)}async getAddresses(){const t=this.provider$.value;return t?await t.request({method:"eth_accounts"}):[]}async getActiveAddress(){const t=this.activeAddressInner$.value;return t||((await this.getAddresses())[0]??null)}async getChainId(){const t=this.provider$.value;if(!t)return null;const e=await t.request({method:"eth_chainId"}).catch(()=>null);return e?Y(e):null}async isConnected(){return!!await this.getActiveAddress()}setActiveAddress(t){this.activeAddressInner$.next(t)}};function Y(t){return typeof t=="number"?t:parseInt(t,16)}function Ee(t){const{code:e,message:r}=t;return e===4001||(r==null?void 0:r.toLowerCase().includes("user rejected"))}var K=class{constructor(t){this.providerDetail=t,this.client=null,this.data=new gt(this.providerDetail.info)}async connect(t){return this.client=await R(t,this.providerDetail.provider),this.data.setProvider(this.providerDetail.provider),!0}async restoreConnect(t,e){this.data.setProvider(this.providerDetail.provider);const n=(await this.data.getAddresses()).length>0&&t!==null;return n?this.client=vt(t,this.providerDetail.provider):this.data.setProvider(null),!n&&e?this.connect(t):n}async disconnect(){return this.client=null,this.data.setProvider(null),!0}async changeChain(t){return this.client?(await this.client.switchChain({id:t}),!0):!1}async isConnected(){var e;return(await((e=this.client)==null?void 0:e.getAddresses())??[]).length>0}setActiveAddress(t){this.data.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await this.client.writeContract({...t,account:e})}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();try{return await this.client.signTypedData({...t,account:e})}catch(n){if(Ee(n))throw n;console.log(n)}const r=JSON.stringify(t,be);return await this.providerDetail.provider.request({method:"eth_signTypedData_v3",params:[e,r]})}};function be(t,e){return typeof e=="bigint"?e.toString():e}function De(t){l.set("chainId",Number(t))}function Ct(){return l.get("chainId",Number)}function We(t){l.set("activeAddress",t)}function Se(){return l.get("activeAddress",String)}function Q(t){l.set("activeWallet",t)}function X(){return l.get("activeWallet",String)}function Te(t){const e=l.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)||(r.add(t),l.set("connectedWallet",[...r.keys()]))}function _e(){return l.get("connectedWallet",JSON.parse)}function Z(t){const e=l.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)&&(r.delete(t),l.set("connectedWallet",[...r.keys()]))}var _=new WeakMap;function o(t){if(_.has(t))return _.get(t);const e=le(["string","string","string"],[t.name,t.rdns??"",t.icon]).slice(0,10);return _.set(t,e),e}var xe=class{constructor(t){this.dataProvider=t,this.chainIdInner$=new q(Ct()??te.eth),this.currentActiveAdapter$=ht(()=>this.dataProvider.update$).pipe(x(null),A(()=>this.dataProvider.currentActiveAdapter),ae(),p({bufferSize:1,refCount:!0})),this.currentActiveAdapterData$=this.currentActiveAdapter$.pipe(A(e=>(e==null?void 0:e.data)??null),p({bufferSize:1,refCount:!0})),this.info$=this.currentActiveAdapterData$.pipe(pt(Boolean),u(e=>e.info$)),this.addresses$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.addresses$)??f([])),I(e=>console.log(e)),p({bufferSize:1,refCount:!0})),this.activeAddress$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.activeAddress$)??f(null)),I(e=>e&&We(e)),p({bufferSize:1,refCount:!0})),this.chainId$=P([this.currentActiveAdapterData$,this.chainIdInner$]).pipe(u(([e,r])=>(e==null?void 0:e.chainId$)??f(r)),I(e=>e&&De(e)),p({bufferSize:1,refCount:!0})),this.disconnect$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.disconnect$)??f()),p({bufferSize:1,refCount:!0})),this.isConnected$=this.currentActiveAdapterData$.pipe(u(e=>(e==null?void 0:e.isConnected$)??f(!1)),p({bufferSize:1,refCount:!0})),P([this.activeAddress$,this.chainId$]).pipe(ee(ie)).subscribe()}getInfo(){if(!this.dataProvider.currentActiveAdapter)throw new Error("");return this.dataProvider.currentActiveAdapter.data.getInfo()}async getAddresses(){const t=await this.getProviderDataAdapter();return t?await t.getAddresses():[]}async getActiveAddress(){if(!this.dataProvider.currentActiveAdapter)return null;const t=await this.getProviderDataAdapter();return t?await t.getActiveAddress():null}async getChainId(){if(!this.dataProvider.currentActiveAdapter)return this.chainIdInner$.value;const t=await this.getProviderDataAdapter();if(!t)return this.chainIdInner$.value;const e=await t.getChainId();return e||this.chainIdInner$.value}async isConnected(){if(!this.dataProvider.currentActiveAdapter)return!1;const t=await this.getProviderDataAdapter();return t?await t.isConnected():!1}async isActiveAddress(t,e){var i,c;const r=o(t),n=await((i=this.dataProvider.currentActiveAdapter)==null?void 0:i.data.getActiveAddress())??null,a=((c=this.dataProvider.currentActiveAdapter)==null?void 0:c.data.getInfo())??null,s=a?o(a):null;return!!n&&!!s&&r===s&&H(n,e)}isActiveWallet(t){var a;const e=o(t),r=((a=this.dataProvider.currentActiveAdapter)==null?void 0:a.data.getInfo())??null,n=r?o(r):null;return!!n&&n===e}isActiveAddress$(t,e){const r=o(t);return P([this.currentActiveAdapter$,this.activeAddress$]).pipe(A(([n,a])=>{const s=n?o(n.data.getInfo()):null;return!!a&&!!s&&r===s&&H(a,e)}))}isActiveWallet$(t){const e=o(t);return this.currentActiveAdapter$.pipe(A(r=>{const n=r?o(r.data.getInfo()):null;return!!n&&n===e}))}setChainId(t){this.chainIdInner$.next(t)}getProviderDataAdapter(){return z(this.currentActiveAdapterData$.pipe(lt(E(0)),ft(null)))}};function qe(){return!!window.ethereum}async function ze(){if(!window.ethereum)throw new Error("injected provider not supported");return{provider:window.ethereum,info:{walletId:"injectedWalletId",uuid:"injectedWallet",name:Oe(),icon:await Re()}}}var tt={default:()=>$(()=>import("./default-icon-UF676TO4-57bNFlKZ.js"),[]).then(t=>t.icon),oneInchWallet:()=>$(()=>import("./one-inch-wallet-icon-5SPUNDFK-BHMg-Ox7.js"),[]).then(t=>t.icon)};function Re(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?tt.oneInchWallet():tt.default()}function Oe(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?"1inch wallet":"Browser wallet"}var ke=class{constructor(t){this.providerDetail=t,this.provider=null,this.client=null,this.data=new gt(this.providerDetail.info)}async isConnected(){var t;return((t=this.provider)==null?void 0:t.isConnected())??!1}async connect(t){if(this.provider)await this.provider.connect();else{const e=await $(()=>import("./multi-connect-provider-SAZA4Z6C-CsQbTFyf.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(r=>r.MultiConnectProvider.connect());this.client=await R(t,e),this.data.setProvider(e),this.provider=e}return!0}async restoreConnect(){if(this.provider)await this.provider.restoreConnect();else{const t=await $(()=>import("./multi-connect-provider-SAZA4Z6C-CsQbTFyf.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(e=>e.MultiConnectProvider.restoreConnect());this.client=await R(t.chainId,t),this.data.setProvider(t),this.provider=t}return!0}async disconnect(){var t;return(t=this.provider)==null||t.disconnect(),!0}async changeChain(t){var e;return await((e=this.client)==null?void 0:e.switchChain({id:t})),!0}setActiveAddress(t){var e;(e=this.provider)==null||e.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.any([this.client.writeContract({...t,account:e}),z(E(60*1e3*3).pipe(u(()=>J(()=>new Error("wallet connect request timed out")))))])}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.race([this.client.signTypedData({...t,account:e}),z(E(60*1e3*3).pipe(u(()=>J(()=>new Error("wallet connect request timed out")))))])}};async function Me(){return{info:{walletId:"walletConnectId",uuid:"walletConnect",name:"Wallet Connect",icon:await je()}}}var Le={default:()=>$(()=>import("./wallet-connect-icon-NJ76IV67-lPk-W8Bs.js"),[]).then(t=>t.icon)};function je(){return Le.default()}var Ne=class{constructor(){this.data=new xe(this),this.activeAdapters=new Map,this.update$=new Xt,this.currentActiveAdapterId=null,this.adapters=new Map}get isConnected(){return this.currentActiveAdapter!==null}get currentActiveAdapter(){return this.currentActiveAdapterId?this.activeAdapters.get(this.currentActiveAdapterId)??null:null}async init(){await this.initWallets(),await this.restoreChainId(),await this.restoreWalletConnection(),this.update$.next()}async getSupportedWallets(){const t=[];return this.adapters.forEach(e=>t.push(e.data.getInfo())),t.sort((e,r)=>{const n=o(e),a=o(r);return n===this.currentActiveAdapterId&&a!==this.currentActiveAdapterId?-1:n!==this.currentActiveAdapterId&&a===this.currentActiveAdapterId?1:this.activeAdapters.has(n)&&this.activeAdapters.has(a)?0:this.activeAdapters.has(n)&&!this.activeAdapters.has(a)?-1:!this.activeAdapters.has(n)&&this.activeAdapters.has(a)?1:0})}async connect(t){const e=await this.data.getChainId(),r=o(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=await this.connectSafe(e,r);return this.afterConnectWallet(n,r),this.update$.next(),n}async addConnection(t){const e=await this.data.getChainId(),r=o(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=this.adapters.get(r);if(!n)throw new Error("Invalid wallet id");if(!this.activeAdapters.has(r))throw new Error(`Wallet adapter ${t.name} not connected`);let a;try{a=await n.connect(e)}catch{a=!1}return this.update$.next(),a}async disconnect(){if(this.currentActiveAdapter===null)return!0;try{const t=await this.currentActiveAdapter.disconnect();return this.currentActiveAdapterId&&this.activeAdapters.delete(this.currentActiveAdapterId),this.currentActiveAdapterId&&Z(this.currentActiveAdapterId),this.currentActiveAdapterId=null,this.update$.next(),t}catch(t){return console.error(t),!1}}async changeChain(t){let e=!0;if(this.currentActiveAdapter)try{e=await this.currentActiveAdapter.changeChain(t)}catch{e=!1}return e&&this.data.setChainId(t),e}getDataAdapter(t){const e=o(t),r=this.adapters.get(e);if(!r)throw new Error(`Invalid wallet info ${t.name} not exist`);return r.data}async setActiveAddress(t,e){const r=o(t);return await this.setActiveAddressInner(r,e)}async writeContract(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.writeContract(t)}async signTypedData(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.signTypedData(t)}async setActiveAddressInner(t,e){var n;let r=!0;if(this.currentActiveAdapterId!==t){const a=await this.data.getChainId();if(!this.adapters.has(t))throw new Error("Invalid wallet not exist");r=await this.connectSafe(a,t),this.afterConnectWallet(r,t)}r&&((n=this.currentActiveAdapter)==null||n.setActiveAddress(e)),this.update$.next()}async connectSafe(t,e,r=!1){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(!this.activeAdapters.has(e)||r){try{a=await n.connect(t)}catch{a=!1}a&&this.activeAdapters.set(e,n)}else a=await n.isConnected(),!r&&!a&&(a=await this.connectSafe(t,e,!0));return a}async restoreConnectSafe(t,e,r){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(this.activeAdapters.has(e))a=await n.isConnected();else{try{a=await n.restoreConnect(t,r)}catch{a=!1}a&&this.activeAdapters.set(e,n)}return a}async restoreChainId(){const t=Ct();t&&await this.changeChain(t)}async restoreWalletConnection(){const t=X(),e=_e();if(!e)return;await this.getSupportedWallets();const r=await this.data.getChainId();for(const i of e){if(i===t||!this.adapters.has(i))continue;const c=await this.restoreConnectSafe(r,i).catch(()=>!1);this.afterConnectWallet(c,i)}if(!t||!this.adapters.has(t))return;const n=await this.restoreConnectSafe(r,t,!0);if(this.afterConnectWallet(n,t),!n)return;const a=Se();!a||!this.currentActiveAdapter||!(await this.currentActiveAdapter.data.getAddresses()).includes(a)||await this.setActiveAddressInner(t,a)}initWallets(){return new Promise(t=>{let e=!1;Zt(window,"eip6963:announceProvider").pipe(I(r=>{e=Fe(window.ethereum,r.detail.provider);const n=o(r.detail.info);this.adapters.has(n)||this.adapters.set(n,new K(r.detail))}),ne(100),ce(1),lt(E(100)),ft(null),I(async()=>{if(!e&&qe()){const a=await ze(),s=o(a.info);this.adapters.has(s)||this.adapters.set(s,new K(a))}const r=await Me(),n=o(r.info);this.adapters.set(n,new ke(r)),t()})).subscribe(),window.dispatchEvent(new Event("eip6963:requestProvider"))})}afterConnectWallet(t,e){t?(this.currentActiveAdapterId=e,Te(e),Q(e)):(Z(e),X()===e&&Q(null),this.currentActiveAdapterId===e&&(this.currentActiveAdapterId=null),this.activeAdapters.has(e)&&(this.adapters.get(e).disconnect().catch(),this.activeAdapters.delete(e)))}};function Fe(t,e){if(t===e)return!0;const r=Object.keys(t??{}),n=Object.keys(e??{});if(r.length!==n.length)return!1;for(const a of r)if(t[a]!==e[a])return!1;return!0}function tr(){return new Ne}export{tr as createConnectWalletController,Ct as getChainIdFromStorage};
//# sourceMappingURL=index.esm-CdKXuL2C.js.map
