const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/multi-connect-provider-YOTZYVBH-e4dogchi.js","assets/index-BNjDdafE.js","assets/index.esm-DhwY4kHm.js","assets/import-wrapper-prod-hit9ecK7.js","assets/index.esm-COc-PyqV.js","assets/index.esm-5Aerb1sL.js","assets/index.esm-Cc9myTra.js","assets/tap-DGvjHJum.js"])))=>i.map(i=>d[i]);
import{_ as $}from"./index-BNjDdafE.js";import{E as qt,B as F,C as Mt,t as zt,u as Rt,v as Ot,T as Nt,x as jt,y as dt,z as Lt,A as P,D as U,F as ut,G as kt,H as ht,I as Ft,J as lt,K as D,M as Ut,N as Bt,O as _,P as Vt,Q as Ht,R as pt,S as Gt,V as Jt,W as x,X as ft,Y as Yt,Z as Kt,_ as Qt,$ as Xt,a0 as Zt,a1 as te,a2 as ee,a3 as re,a4 as ne,a5 as ae,a6 as se,a7 as ie,a8 as ce,a9 as oe,d as de,s as l,o as w,aa as tt,ab as b,b as ue,g as wt,m as he}from"./index.esm-Cc9myTra.js";import{O as At,d as le,o as vt,c as gt,S as mt,C as pe,s as R,m as A,a as f,e as fe,f as we,b as et}from"./index.esm-DhwY4kHm.js";import{storage as p}from"./index.esm-COc-PyqV.js";import{B as O,c as S}from"./combineLatest-Bzt_9bb6.js";import{d as Ct}from"./defer-BRewiDsk.js";import{f as yt,t as It}from"./takeUntil-B9okj2Im.js";import{t as E}from"./tap-DGvjHJum.js";import{a as Ae}from"./asap-D-qxMtYG.js";import{f as N}from"./firstValueFrom-RTAQ66ca.js";function rt(t,e){var r=le(t)?t:function(){return t},n=function(a){return a.error(r())};return new At(n)}function Pt(t){return vt(function(e,r){var n=!1;e.subscribe(gt(r,function(a){n=!0,r.next(a)},function(){n||r.next(t),r.complete()}))})}function ve(t){return t<=0?function(){return qt}:vt(function(e,r){var n=0;e.subscribe(gt(r,function(a){++n<=t&&(r.next(a),t<=n&&r.complete())}))})}class W extends F{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:e,docsSlug:"account",name:"AccountNotFoundError"})}}class q extends F{constructor({docsPath:e,metaMessages:r,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:e,metaMessages:r,name:"AccountTypeNotSupportedError"})}}function Et({chain:t,currentChainId:e}){if(!t)throw new Mt;if(e!==t.id)throw new zt({chain:t,currentChainId:e})}function ge(t,{docsPath:e,...r}){const n=(()=>{const a=Rt(t,r);return a instanceof Ot?t:a})();return new Nt(n,{docsPath:e,...r})}const nt=new jt(128);async function B(t,e){var J,Y,K,Q;const{account:r=t.account,chain:n=t.chain,accessList:a,authorizationList:s,blobs:i,data:c,gas:h,gasPrice:u,maxFeePerBlobGas:v,maxFeePerGas:g,maxPriorityFeePerGas:C,nonce:V,value:H,...G}=e;if(typeof r>"u")throw new W({docsPath:"/docs/actions/wallet/sendTransaction"});const o=r?D(r):null;try{dt(e);const m=await(async()=>{if(e.to)return e.to;if(s&&s.length>0)return await Lt({authorization:s[0]}).catch(()=>{throw new F("`to` is required. Could not infer from `authorizationList`.")})})();if((o==null?void 0:o.type)==="json-rpc"||o===null){let y;n!==null&&(y=await P(t,U,"getChainId")({}),Et({currentChainId:y,chain:n}));const T=(K=(Y=(J=t.chain)==null?void 0:J.formatters)==null?void 0:Y.transactionRequest)==null?void 0:K.format,Z=(T||ut)({...kt(G,{format:T}),accessList:a,authorizationList:s,blobs:i,chainId:y,data:c,from:o==null?void 0:o.address,gas:h,gasPrice:u,maxFeePerBlobGas:v,maxFeePerGas:g,maxPriorityFeePerGas:C,nonce:V,to:m,value:H}),bt=nt.get(t.uid)?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:bt,params:[Z]},{retryCount:0})}catch(_t){const I=_t;if(I.name==="InvalidInputRpcError"||I.name==="InvalidParamsRpcError"||I.name==="MethodNotFoundRpcError"||I.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[Z]},{retryCount:0}).then(xt=>(nt.set(t.uid,!0),xt));throw I}}if((o==null?void 0:o.type)==="local"){const y=await P(t,ht,"prepareTransactionRequest")({account:o,accessList:a,authorizationList:s,blobs:i,chain:n,data:c,gas:h,gasPrice:u,maxFeePerBlobGas:v,maxFeePerGas:g,maxPriorityFeePerGas:C,nonce:V,nonceManager:o.nonceManager,parameters:[...Ft,"sidecars"],value:H,...G,to:m}),T=(Q=n==null?void 0:n.serializers)==null?void 0:Q.transaction,X=await o.signTransaction(y,{serializer:T});return await P(t,lt,"sendRawTransaction")({serializedTransaction:X})}throw(o==null?void 0:o.type)==="smart"?new q({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new q({docsPath:"/docs/actions/wallet/sendTransaction",type:o==null?void 0:o.type})}catch(m){throw m instanceof q?m:ge(m,{...e,account:o,chain:e.chain||void 0})}}async function me(t,e){const{abi:r,account:n=t.account,address:a,args:s,dataSuffix:i,functionName:c,...h}=e;if(typeof n>"u")throw new W({docsPath:"/docs/contract/writeContract"});const u=n?D(n):null,v=Ut({abi:r,args:s,functionName:c});try{return await P(t,B,"sendTransaction")({data:`${v}${i?i.replace("0x",""):""}`,to:a,account:u,...h})}catch(g){throw Bt(g,{abi:r,address:a,args:s,docsPath:"/docs/contract/writeContract",functionName:c,sender:u==null?void 0:u.address})}}async function Ce(t,{chain:e}){const{id:r,name:n,nativeCurrency:a,rpcUrls:s,blockExplorers:i}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:_(r),chainName:n,nativeCurrency:a,rpcUrls:s.default.http,blockExplorerUrls:i?Object.values(i).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function ye(t,e={}){const{key:r="custom",name:n="Custom Provider",retryDelay:a}=e;return({retryCount:s})=>Vt({key:r,name:n,request:t.request.bind(t),retryCount:e.retryCount??s,retryDelay:a,type:"custom"})}function Ie(t,e){if(t.length!==e.length)throw new Ht({expectedLength:t.length,givenLength:e.length});const r=[];for(let n=0;n<t.length;n++){const a=t[n],s=e[n];r.push($t(a,s))}return pt(r)}function $t(t,e,r=!1){if(t==="address"){const i=e;if(!Gt(i))throw new Jt({address:i});return x(i.toLowerCase(),{size:r?32:null})}if(t==="string")return ft(e);if(t==="bytes")return e;if(t==="bool")return x(Yt(e),{size:r?32:1});const n=t.match(Kt);if(n){const[i,c,h="256"]=n,u=Number.parseInt(h)/8;return _(e,{size:r?32:u,signed:c==="int"})}const a=t.match(Qt);if(a){const[i,c]=a;if(Number.parseInt(c)!==(e.length-2)/2)throw new Xt({expectedSize:Number.parseInt(c),givenSize:(e.length-2)/2});return x(e,{dir:"right",size:r?32:null})}const s=t.match(Zt);if(s&&Array.isArray(e)){const[i,c]=s,h=[];for(let u=0;u<e.length;u++)h.push($t(c,e[u],!0));return h.length===0?"0x":pt(h)}throw new te(t)}function Pe(t,e){const{abi:r,args:n,bytecode:a,...s}=e,i=ee({abi:r,args:n,bytecode:a});return B(t,{...s,data:i})}async function Ee(t){var r;return((r=t.account)==null?void 0:r.type)==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(n=>re(n))}async function $e(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}async function De(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(r=>ne(r))}async function We(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}async function Te(t,{account:e=t.account,message:r}){if(!e)throw new W({docsPath:"/docs/actions/wallet/signMessage"});const n=D(e);if(n.signMessage)return n.signMessage({message:r});const a=typeof r=="string"?ft(r):r.raw instanceof Uint8Array?ae(r.raw):r.raw;return t.request({method:"personal_sign",params:[a,n.address]},{retryCount:0})}async function Se(t,e){var u,v,g,C;const{account:r=t.account,chain:n=t.chain,...a}=e;if(!r)throw new W({docsPath:"/docs/actions/wallet/signTransaction"});const s=D(r);dt({account:s,...e});const i=await P(t,U,"getChainId")({});n!==null&&Et({currentChainId:i,chain:n});const c=(n==null?void 0:n.formatters)||((u=t.chain)==null?void 0:u.formatters),h=((v=c==null?void 0:c.transactionRequest)==null?void 0:v.format)||ut;return s.signTransaction?s.signTransaction({...a,chainId:i},{serializer:(C=(g=t.chain)==null?void 0:g.serializers)==null?void 0:C.transaction}):await t.request({method:"eth_signTransaction",params:[{...h(a),chainId:_(i),from:s.address}]},{retryCount:0})}async function be(t,e){const{account:r=t.account,domain:n,message:a,primaryType:s}=e;if(!r)throw new W({docsPath:"/docs/actions/wallet/signTypedData"});const i=D(r),c={EIP712Domain:se({domain:n}),...e.types};if(ie({domain:n,message:a,primaryType:s,types:c}),i.signTypedData)return i.signTypedData({domain:n,message:a,primaryType:s,types:c});const h=ce({domain:n,message:a,primaryType:s,types:c});return t.request({method:"eth_signTypedData_v4",params:[i.address,h]},{retryCount:0})}async function _e(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:_(e)}]},{retryCount:0})}async function xe(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}function qe(t){return{addChain:e=>Ce(t,e),deployContract:e=>Pe(t,e),getAddresses:()=>Ee(t),getChainId:()=>U(t),getPermissions:()=>$e(t),prepareTransactionRequest:e=>ht(t,e),requestAddresses:()=>De(t),requestPermissions:e=>We(t,e),sendRawTransaction:e=>lt(t,e),sendTransaction:e=>B(t,e),signMessage:e=>Te(t,e),signTransaction:e=>Se(t,e),signTypedData:e=>be(t,e),switchChain:e=>_e(t,e),watchAsset:e=>xe(t,e),writeContract:e=>me(t,e)}}function Me(t){const{key:e="wallet",name:r="Wallet Client",transport:n}=t;return oe({...t,key:e,name:r,transport:n,type:"walletClient"}).extend(qe)}async function j(t,e,r){const n=Dt(t,e,r);await n.requestAddresses().catch(s=>{var i,c;if(s.core===4001||(c=(i=s.message)==null?void 0:i.toLowerCase())!=null&&c.includes("user reject")||s.details==="Cancelled")throw s});const a=await n.getChainId();return t!==a&&await n.switchChain(wt(t)),n}function Dt(t,e,r){return Me({chain:wt(t),transport:ye(e),account:r})}function M(t,e){return new At(r=>{const n=a=>{r.next(a)};return t.on(e,n),()=>{if("removeListener"in t)return t.removeListener(e,n);console.warn("unable to unsubscribe from provider",t,e)}})}var Wt=class{constructor(t){this.info=t,this.provider$=new O(null),this.activeAddressInner$=new O(null),this.providerOrDisconnect$=he(this.provider$,Ct(()=>this.disconnect$).pipe(A(()=>null))),this.addresses$=this.providerOrDisconnect$.pipe(l(e=>e?et(this.getAddresses()).pipe(l(r=>M(e,"accountsChanged").pipe(R(r)))):w([])),f({bufferSize:1,refCount:!0})),this.activeAddress$=S([this.addresses$,this.activeAddressInner$]).pipe(A(([e,r])=>r||e[0]),f({bufferSize:1,refCount:!0})),this.chainId$=this.providerOrDisconnect$.pipe(l(e=>e?et(this.getChainId()).pipe(l(r=>M(e,"chainChanged").pipe(A(n=>at(n)),R(r)))):w(null)),f({bufferSize:1,refCount:!0})),this.disconnect$=this.provider$.pipe(yt(Boolean),l(e=>M(e,"disconnect"))),this.isConnected$=this.activeAddress$.pipe(A(e=>!!e)),this.info$=w(t)}getInfo(){return this.info}setProvider(t){this.provider$.next(t)}async getAddresses(){const t=this.provider$.value;return t?await t.request({method:"eth_accounts"}):[]}async getActiveAddress(){const t=this.activeAddressInner$.value;return t||((await this.getAddresses())[0]??null)}async getChainId(){const t=this.provider$.value;if(!t)return null;const e=await t.request({method:"eth_chainId"}).catch(()=>null);return e?at(e):null}async isConnected(){return!!await this.getActiveAddress()}setActiveAddress(t){this.activeAddressInner$.next(t)}};function at(t){return typeof t=="number"?t:parseInt(t,16)}function ze(t){const{code:e,message:r}=t;return e===4001||(r==null?void 0:r.toLowerCase().includes("user rejected"))}var L=class{constructor(t){this.providerDetail=t,this.client=null,this.data=new Wt(this.providerDetail.info)}get info(){return this.providerDetail.info}async connect(t){return this.client=await j(t,this.providerDetail.provider),this.data.setProvider(this.providerDetail.provider),!0}async restoreConnect(t,e){this.data.setProvider(this.providerDetail.provider);const n=(await this.data.getAddresses()).length>0&&t!==null;return n?this.client=Dt(t,this.providerDetail.provider):this.data.setProvider(null),!n&&e?this.connect(t):n}async disconnect(){return this.client=null,this.data.setProvider(null),!0}async changeChain(t){return this.client?(await this.client.switchChain({id:t}),!0):!1}async isConnected(){var e;return(await((e=this.client)==null?void 0:e.getAddresses())??[]).length>0}setActiveAddress(t){this.data.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await this.client.writeContract({...t,account:e})}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();try{return await this.client.signTypedData({...t,account:e})}catch(n){if(ze(n))throw n;console.log(n)}const r=JSON.stringify(t,Re);return await this.providerDetail.provider.request({method:"eth_signTypedData_v3",params:[e,r]})}};function Re(t,e){return typeof e=="bigint"?e.toString():e}function Oe(t){p.set("chainId",Number(t))}function Tt(){return p.get("chainId",Number)}function Ne(t){p.set("activeAddress",t)}function je(){return p.get("activeAddress",String)}function st(t){p.set("activeWallet",t)}function it(){return p.get("activeWallet",String)}function Le(t){const e=p.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)||(r.add(t),p.set("connectedWallet",[...r.keys()]))}function ke(){return p.get("connectedWallet",JSON.parse)}function ct(t){const e=p.get("connectedWallet",JSON.parse),r=new Set(e);r.has(t)&&(r.delete(t),p.set("connectedWallet",[...r.keys()]))}var z=new WeakMap;function d(t){if(z.has(t))return z.get(t);const e=Ie(["string","string","string"],[t.name,t.rdns??"",t.icon]).slice(0,10);return z.set(t,e),e}var St=class{constructor(t){this.dataProvider=t,this.chainIdInner$=new O(Tt()??pe.eth),this.currentActiveAdapter$=Ct(()=>this.dataProvider.update$).pipe(R(null),A(()=>this.dataProvider.currentActiveAdapter),de(),f({bufferSize:1,refCount:!0})),this.currentActiveAdapterData$=this.currentActiveAdapter$.pipe(A(e=>(e==null?void 0:e.data)??null),f({bufferSize:1,refCount:!0})),this.info$=this.currentActiveAdapterData$.pipe(yt(Boolean),l(e=>e.info$)),this.addresses$=this.currentActiveAdapterData$.pipe(l(e=>(e==null?void 0:e.addresses$)??w([])),E(e=>console.log(e)),f({bufferSize:1,refCount:!0})),this.activeAddress$=this.currentActiveAdapterData$.pipe(l(e=>(e==null?void 0:e.activeAddress$)??w(null)),E(e=>e&&Ne(e)),f({bufferSize:1,refCount:!0})),this.chainId$=S([this.currentActiveAdapterData$,this.chainIdInner$]).pipe(l(([e,r])=>(e==null?void 0:e.chainId$)??w(r)),E(e=>e&&Oe(e)),f({bufferSize:1,refCount:!0})),this.disconnect$=this.currentActiveAdapterData$.pipe(l(e=>(e==null?void 0:e.disconnect$)??w()),f({bufferSize:1,refCount:!0})),this.isConnected$=this.currentActiveAdapterData$.pipe(l(e=>(e==null?void 0:e.isConnected$)??w(!1)),f({bufferSize:1,refCount:!0})),S([this.activeAddress$,this.chainId$]).pipe(fe(Ae)).subscribe()}getInfo(){if(!this.dataProvider.currentActiveAdapter)throw new Error("");return this.dataProvider.currentActiveAdapter.data.getInfo()}async getAddresses(){const t=await this.getProviderDataAdapter();return t?await t.getAddresses():[]}async getActiveAddress(){if(!this.dataProvider.currentActiveAdapter)return null;const t=await this.getProviderDataAdapter();return t?await t.getActiveAddress():null}async getChainId(){if(!this.dataProvider.currentActiveAdapter)return this.chainIdInner$.value;const t=await this.getProviderDataAdapter();if(!t)return this.chainIdInner$.value;const e=await t.getChainId();return e||this.chainIdInner$.value}async isConnected(){if(!this.dataProvider.currentActiveAdapter)return!1;const t=await this.getProviderDataAdapter();return t?await t.isConnected():!1}async isActiveAddress(t,e){var i,c;const r=d(t),n=await((i=this.dataProvider.currentActiveAdapter)==null?void 0:i.data.getActiveAddress())??null,a=((c=this.dataProvider.currentActiveAdapter)==null?void 0:c.data.getInfo())??null,s=a?d(a):null;return!!n&&!!s&&r===s&&tt(n,e)}isActiveWallet(t){var a;const e=d(t),r=((a=this.dataProvider.currentActiveAdapter)==null?void 0:a.data.getInfo())??null,n=r?d(r):null;return!!n&&n===e}isActiveAddress$(t,e){const r=d(t);return S([this.currentActiveAdapter$,this.activeAddress$]).pipe(A(([n,a])=>{const s=n?d(n.data.getInfo()):null;return!!a&&!!s&&r===s&&tt(a,e)}))}isActiveWallet$(t){const e=d(t);return this.currentActiveAdapter$.pipe(A(r=>{const n=r?d(r.data.getInfo()):null;return!!n&&n===e}))}setChainId(t){this.chainIdInner$.next(t)}getProviderDataAdapter(){return N(this.currentActiveAdapterData$.pipe(It(b(0)),Pt(null)))}};function Fe(){return!!window.ethereum}async function k(t=window.ethereum){if(!t)throw new Error("injected provider not supported");return{provider:t,info:{walletId:"injectedWalletId",uuid:"injectedWallet",name:Be(),icon:await Ue()}}}var ot={default:()=>$(()=>import("./default-icon-UF676TO4-57bNFlKZ.js"),[]).then(t=>t.icon),oneInchWallet:()=>$(()=>import("./one-inch-wallet-icon-5SPUNDFK-BHiOEM79.js"),[]).then(t=>t.icon)};function Ue(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?ot.oneInchWallet():ot.default()}function Be(){var t;return(t=window.ethereum)!=null&&t.isOneInchWallet?"1inch wallet":"Browser wallet"}var Ve=class{constructor(t){this.providerDetail=t,this.provider=null,this.client=null,this.data=new Wt(this.providerDetail.info)}get info(){return this.providerDetail.info}async isConnected(){var t;return((t=this.provider)==null?void 0:t.isConnected())??!1}async connect(t){if(this.provider)await this.provider.connect();else{const e=await $(()=>import("./multi-connect-provider-YOTZYVBH-e4dogchi.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(r=>r.MultiConnectProvider.connect());this.client=await j(t,e),this.data.setProvider(e),this.provider=e}return!0}async restoreConnect(){if(this.provider)await this.provider.restoreConnect();else{const t=await $(()=>import("./multi-connect-provider-YOTZYVBH-e4dogchi.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])).then(e=>e.MultiConnectProvider.restoreConnect());this.client=await j(t.chainId,t),this.data.setProvider(t),this.provider=t}return!0}async disconnect(){var t;return(t=this.provider)==null||t.disconnect(),!0}async changeChain(t){var e;return await((e=this.client)==null?void 0:e.switchChain({id:t})),!0}setActiveAddress(t){var e;(e=this.provider)==null||e.setActiveAddress(t)}async writeContract(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.any([this.client.writeContract({...t,account:e}),N(b(60*1e3*3).pipe(l(()=>rt(()=>new Error("wallet connect request timed out")))))])}async signTypedData(t){if(!await this.isConnected()||!this.client)throw new Error("Wallet not connected");const e=await this.data.getActiveAddress();return await Promise.race([this.client.signTypedData({...t,account:e}),N(b(60*1e3*3).pipe(l(()=>rt(()=>new Error("wallet connect request timed out")))))])}};async function He(){return{info:{walletId:"walletConnectId",uuid:"walletConnect",name:"Wallet Connect",icon:await Je()}}}var Ge={default:()=>$(()=>import("./wallet-connect-icon-NJ76IV67-lPk-W8Bs.js"),[]).then(t=>t.icon)};function Je(){return Ge.default()}var Ye=class{constructor(){this.data=new St(this),this.activeAdapters=new Map,this.update$=new mt,this.currentActiveAdapterId=null,this.adapters=new Map}get isConnected(){return this.currentActiveAdapter!==null}get connectedWalletInfo(){var t;return((t=this.currentActiveAdapter)==null?void 0:t.info)??null}get currentActiveAdapter(){return this.currentActiveAdapterId?this.activeAdapters.get(this.currentActiveAdapterId)??null:null}async init(){await this.initWallets(),await this.restoreChainId(),await this.restoreWalletConnection(),this.update$.next()}async getSupportedWallets(){const t=[];return this.adapters.forEach(e=>t.push(e.data.getInfo())),t.sort((e,r)=>{const n=d(e),a=d(r);return n===this.currentActiveAdapterId&&a!==this.currentActiveAdapterId?-1:n!==this.currentActiveAdapterId&&a===this.currentActiveAdapterId?1:this.activeAdapters.has(n)&&this.activeAdapters.has(a)?0:this.activeAdapters.has(n)&&!this.activeAdapters.has(a)?-1:!this.activeAdapters.has(n)&&this.activeAdapters.has(a)?1:0})}async connect(t){const e=await this.data.getChainId(),r=d(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=await this.connectSafe(e,r);return this.afterConnectWallet(n,r),this.update$.next(),n}async addConnection(t){const e=await this.data.getChainId(),r=d(t);if(!this.adapters.has(r))throw new Error(`Invalid wallet info ${t.name} not exist`);const n=this.adapters.get(r);if(!n)throw new Error("Invalid wallet id");if(!this.activeAdapters.has(r))throw new Error(`Wallet adapter ${t.name} not connected`);let a;try{a=await n.connect(e)}catch{a=!1}return this.update$.next(),a}async disconnect(){if(this.currentActiveAdapter===null)return!0;try{const t=await this.currentActiveAdapter.disconnect();return this.currentActiveAdapterId&&this.activeAdapters.delete(this.currentActiveAdapterId),this.currentActiveAdapterId&&ct(this.currentActiveAdapterId),this.currentActiveAdapterId=null,this.update$.next(),t}catch(t){return console.error(t),!1}}async changeChain(t){let e=!0;if(this.currentActiveAdapter)try{e=await this.currentActiveAdapter.changeChain(t)}catch{e=!1}return e&&this.data.setChainId(t),e}getDataAdapter(t){const e=d(t),r=this.adapters.get(e);if(!r)throw new Error(`Invalid wallet info ${t.name} not exist`);return r.data}async setActiveAddress(t,e){const r=d(t);return await this.setActiveAddressInner(r,e)}async writeContract(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.writeContract(t)}async signTypedData(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.signTypedData(t)}async setActiveAddressInner(t,e){var n;let r=!0;if(this.currentActiveAdapterId!==t){const a=await this.data.getChainId();if(!this.adapters.has(t))throw new Error("Invalid wallet not exist");r=await this.connectSafe(a,t),this.afterConnectWallet(r,t)}r&&((n=this.currentActiveAdapter)==null||n.setActiveAddress(e)),this.update$.next()}async connectSafe(t,e,r=!1){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(!this.activeAdapters.has(e)||r){try{a=await n.connect(t)}catch{a=!1}a&&this.activeAdapters.set(e,n)}else a=await n.isConnected(),!r&&!a&&(a=await this.connectSafe(t,e,!0));return a}async restoreConnectSafe(t,e,r){const n=this.adapters.get(e);if(!n)throw new Error("Invalid wallet id");let a;if(this.activeAdapters.has(e))a=await n.isConnected();else{try{a=await n.restoreConnect(t,r)}catch{a=!1}a&&this.activeAdapters.set(e,n)}return a}async restoreChainId(){const t=Tt();t&&await this.changeChain(t)}async restoreWalletConnection(){const t=it(),e=ke();if(!e)return;await this.getSupportedWallets();const r=await this.data.getChainId();for(const i of e){if(i===t||!this.adapters.has(i))continue;const c=await this.restoreConnectSafe(r,i).catch(()=>!1);this.afterConnectWallet(c,i)}if(!t||!this.adapters.has(t))return;const n=await this.restoreConnectSafe(r,t,!0);if(this.afterConnectWallet(n,t),!n)return;const a=je();!a||!this.currentActiveAdapter||!(await this.currentActiveAdapter.data.getAddresses()).includes(a)||await this.setActiveAddressInner(t,a)}initWallets(){return new Promise(t=>{let e=!1;we(window,"eip6963:announceProvider").pipe(E(r=>{e=Ke(window.ethereum,r.detail.provider);const n=d(r.detail.info);this.adapters.has(n)||this.adapters.set(n,new L(r.detail))}),ue(100),ve(1),It(b(100)),Pt(null),E(async()=>{if(!e&&Fe()){const a=await k(),s=d(a.info);this.adapters.has(s)||this.adapters.set(s,new L(a))}const r=await He(),n=d(r.info);this.adapters.set(n,new Ve(r)),t()})).subscribe(),window.dispatchEvent(new Event("eip6963:requestProvider"))})}afterConnectWallet(t,e){t?(this.currentActiveAdapterId=e,Le(e),st(e)):(ct(e),it()===e&&st(null),this.currentActiveAdapterId===e&&(this.currentActiveAdapterId=null),this.activeAdapters.has(e)&&(this.adapters.get(e).disconnect().catch(),this.activeAdapters.delete(e)))}};function Ke(t,e){if(t===e)return!0;const r=Object.keys(t??{}),n=Object.keys(e??{});if(r.length!==n.length)return!1;for(const a of r)if(t[a]!==e[a])return!1;return!0}function cr(){return new Ye}var or=class{constructor(t){this.config=t,this.currentActiveAdapter=null,this.activeAdapters=new Map,this.data=new St(this),this.update$=new mt}get isConnected(){return!0}get connectedWalletInfo(){var t;return((t=this.currentActiveAdapter)==null?void 0:t.info)??null}async init(){if(!this.config.walletProvider)return;const t=await k(this.config.walletProvider),e=d(t.info),r=new L(t);this.activeAdapters.set(e,r),await r.connect(this.config.chainId),this.currentActiveAdapter=r,this.update$.next()}async getSupportedWallets(){return[(await k(this.config.walletProvider)).info]}async writeContract(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.writeContract(t)}async signTypedData(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.signTypedData(t)}async changeChain(t){if(!this.currentActiveAdapter||!this.currentActiveAdapter.client)throw new Error("Wallet not connected");return await this.currentActiveAdapter.changeChain(t)}connect(t){throw new Error("Method not implemented.")}addConnection(t){throw new Error("Method not implemented.")}disconnect(){throw new Error("Method not implemented.")}getDataAdapter(t){throw new Error("Method not implemented.")}setActiveAddress(t,e){throw new Error("Method not implemented.")}};export{or as ConnectWalletEmbeddedController,cr as createConnectWalletController,Tt as getChainIdFromStorage};
//# sourceMappingURL=index.esm-uJqxAW60.js.map
